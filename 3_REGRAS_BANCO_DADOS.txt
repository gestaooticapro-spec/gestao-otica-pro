=== CONTEÚDO: 3_REGRAS_BANCO_DADOS.txt ===


==================================================
ARQUIVO: .\src\lib\database.types.ts
==================================================
// ARQUIVO: src/lib/database.types.ts

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export interface Database {
  public: {
    Tables: {
      // --- TABELAS DE CONFIGURAÇÃO & GESTÃO ---
      
      profiles: {
        Row: {
          id: string
          role: string | null
          store_id: number | null
          tenant_id: string | null
          created_at: string
        }
        Insert: {
          id: string
          role?: string | null
          store_id?: number | null
          tenant_id?: string | null
          created_at?: string
        }
        Update: {
          id?: string
          role?: string | null
          store_id?: number | null
          tenant_id?: string | null
          created_at?: string
        }
      }
      
      employees: {
        Row: {
          id: number
          store_id: number
          full_name: string
          pin: string
          is_active: boolean
          role: 'vendedor' | 'gerente' | 'tecnico'
          created_at: string
          comm_rate_guaranteed: number | null
          comm_rate_store_credit: number | null
          comm_rate_store_total: number | null
          comm_rate_received: number | null
          comm_rate_profit: number | null
          comm_tiers_json: Json | null
        }
        Insert: {
          id?: number
          store_id: number
          full_name: string
          pin: string
          is_active?: boolean
          role?: 'vendedor' | 'gerente' | 'tecnico'
          created_at?: string
          comm_rate_guaranteed?: number | null
          comm_rate_store_credit?: number | null
          comm_rate_store_total?: number | null
          comm_rate_received?: number | null
          comm_rate_profit?: number | null
          comm_tiers_json?: Json | null
        }
        Update: {
          id?: number
          store_id?: number
          full_name?: string
          pin?: string
          is_active?: boolean
          role?: 'vendedor' | 'gerente' | 'tecnico'
          created_at?: string
          comm_rate_guaranteed?: number | null
          comm_rate_store_credit?: number | null
          comm_rate_store_total?: number | null
          comm_rate_received?: number | null
          comm_rate_profit?: number | null
          comm_tiers_json?: Json | null
        }
      }

      stores: {
        Row: {
          id: number
          name: string
          tenant_id: string
          settings: Json | null
          // Campos adicionais de perfil da loja
          razao_social: string | null
          cnpj: string | null
          inscricao_estadual: string | null
          whatsapp: string | null
          phone: string | null
          email: string | null
          website: string | null
          cep: string | null
          street: string | null
          number: string | null
          neighborhood: string | null
          city: string | null
          state: string | null
        }
        Insert: {
          id?: number
          name: string
          tenant_id: string
          settings?: Json | null
          razao_social?: string | null
          cnpj?: string | null
          inscricao_estadual?: string | null
          whatsapp?: string | null
          phone?: string | null
          email?: string | null
          website?: string | null
          cep?: string | null
          street?: string | null
          number?: string | null
          neighborhood?: string | null
          city?: string | null
          state?: string | null
        }
        Update: {
          id?: number
          name?: string
          tenant_id?: string
          settings?: Json | null
          razao_social?: string | null
          cnpj?: string | null
          inscricao_estadual?: string | null
          whatsapp?: string | null
          phone?: string | null
          email?: string | null
          website?: string | null
          cep?: string | null
          street?: string | null
          number?: string | null
          neighborhood?: string | null
          city?: string | null
          state?: string | null
        }
      }

      suppliers: {
        Row: {
          id: number
          store_id: number
          tenant_id: string | null
          nome_fantasia: string
          razao_social: string | null
          cnpj: string | null
          inscricao_estadual: string | null
          telefone: string | null
          cidade: string | null
          uf: string | null
          created_at: string
        }
        Insert: {
          id?: number
          store_id: number
          tenant_id?: string | null
          nome_fantasia: string
          razao_social?: string | null
          cnpj?: string | null
          inscricao_estadual?: string | null
          telefone?: string | null
          cidade?: string | null
          uf?: string | null
          created_at?: string
        }
        Update: {
          id?: number
          nome_fantasia?: string
          [key: string]: any
        }
      }

      // --- FINANCEIRO (CONTAS A PAGAR & RECEBER) ---

      accounts_payable: {
        Row: {
          id: number
          tenant_id: string | null
          store_id: number
          description: string
          amount: number
          amount_paid: number
          due_date: string
          payment_date: string | null
          status: 'Pendente' | 'Pago' | 'Cancelado'
          category: string | null
          supplier_id: number | null
          created_by_user_id: string | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: number
          tenant_id?: string | null
          store_id: number
          description: string
          amount: number
          amount_paid?: number
          due_date: string
          payment_date?: string | null
          status?: 'Pendente' | 'Pago' | 'Cancelado'
          category?: string | null
          supplier_id?: number | null
          created_by_user_id?: string | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          [key: string]: any
        }
      }

      // --- NOVA TABELA: CONTAS A RECEBER ---
      contas_a_receber: {
        Row: {
            id: number
            tenant_id: string | null
            store_id: number
            pagamento_id: number
            data_prevista: string
            valor_bruto: number
            valor_taxa: number | null
            valor_liquido: number
            status: string
        }
        Insert: {
            id?: number
            tenant_id?: string | null
            store_id: number
            pagamento_id: number
            data_prevista: string
            valor_bruto: number
            valor_taxa?: number | null
            valor_liquido: number
            status?: string
        }
        Update: {
            [key: string]: any
        }
      }

      // --- IMPORTAÇÃO ---
      imported_invoices: {
        Row: {
          id: number
          store_id: number
          tenant_id: string | null
          access_key: string
          nfe_number: string | null
          series: string | null
          supplier_id: number | null
          imported_at: string
        }
        Insert: {
          id?: number
          store_id: number
          tenant_id?: string | null
          access_key: string
          nfe_number?: string | null
          series?: string | null
          supplier_id?: number | null
          imported_at?: string
        }
        Update: {
          [key: string]: any
        }
      }

      // --- CLIENTES & ASSISTÊNCIA ---

      customers: {
        Row: {
          id: number
          store_id: number
          full_name: string
          cpf: string | null
          rg: string | null
          birth_date: string | null
          phone: string | null
          fone_movel: string | null
          email: string | null
          rua: string | null
          numero: string | null
          bairro: string | null
          cidade: string | null
          uf: string | null
          cep: string | null
          complemento: string | null
          naturalidade: string | null
          estado_civil: string | null
          pai: string | null
          mae: string | null
          conjuge_nome: string | null
          conjuge_nascimento: string | null
          conjuge_naturalidade: string | null
          conjuge_trabalho: string | null
          conjuge_fone: string | null
          comercial_trabalho: string | null
          comercial_cargo: string | null
          comercial_endereco: string | null
          comercial_fone: string | null
          comercial_renda: number | null
          obs_comercial: string | null
          obs_residencial: string | null
          ref_comercio_1: string | null
          ref_comercio_2: string | null
          ref_pessoal_1: string | null
          ref_pessoal_2: string | null
          obs_debito: string | null
          notes: string | null
          faixa_etaria: string | null
          is_spc: boolean | null
          created_at: string
        }
        Insert: {
          id?: number
          store_id: number
          full_name: string
          cpf?: string | null
          is_spc?: boolean | null
          tenant_id?: string
          [key: string]: any 
        }
        Update: {
          id?: number
          full_name?: string
          [key: string]: any
        }
      }
      
      dependentes: {
        Row: {
          id: number
          store_id: number
          customer_id: number
          full_name: string
          parentesco: string | null
          birth_date: string | null
          created_at: string
        }
        Insert: {
          id?: number
          store_id: number
          customer_id: number
          full_name: string
          parentesco?: string | null
          birth_date?: string | null
          created_at?: string
          tenant_id?: string
        }
        Update: {
          [key: string]: any
        }
      }

      // --- NOVAS TABELAS DE ASSISTÊNCIA ---
      assistance_tickets: {
        Row: {
            id: number
            tenant_id: string | null
            store_id: number
            tracking_token: string // UUID
            customer_id: number
            venda_original_id: number | null
            product_id: number | null
            product_descricao: string
            contato_usado: string | null
            modalidade: string
            status: string
            status_publico: string | null
            descricao_defeito: string | null
            fotos_urls: Json | null
            dt_abertura: string | null
            dt_solicitacao_peca: string | null
            dt_chegada_peca: string | null
            dt_troca_cliente: string | null
            dt_envio_fornecedor: string | null
            dt_conclusao: string | null
            rastreio_entrada: string | null
            rastreio_saida: string | null
            created_by_user_id: string | null
            created_at: string | null
            updated_at: string | null
        }
        Insert: {
            id?: number
            tenant_id?: string | null
            store_id: number
            tracking_token?: string
            customer_id: number
            venda_original_id?: number | null
            product_id?: number | null
            product_descricao: string
            contato_usado?: string | null
            modalidade: string
            status: string
            status_publico?: string | null
            descricao_defeito?: string | null
            fotos_urls?: Json | null
            created_by_user_id?: string | null
            [key: string]: any
        }
        Update: {
            [key: string]: any
        }
      }

      assistance_timeline: {
        Row: {
            id: number
            ticket_id: number
            tenant_id: string | null
            tipo: string
            mensagem: string
            usuario_id: string | null
            created_at: string
        }
        Insert: {
            id?: number
            ticket_id: number
            tenant_id?: string | null
            tipo: string
            mensagem: string
            usuario_id?: string | null
            created_at?: string
        }
        Update: {
            [key: string]: any
        }
      }

      // --- CARTEIRA E COMISSÕES ---
      customer_wallets: {
        Row: {
          id: number
          tenant_id: string | null
          store_id: number
          customer_id: number
          balance: number
          updated_at: string
        }
        Insert: {
          id?: number
          tenant_id?: string | null
          store_id: number
          customer_id: number
          balance?: number
          updated_at?: string
        }
        Update: {
          balance?: number
          updated_at?: string
          [key: string]: any
        }
      }

      wallet_transactions: {
        Row: {
          id: number
          tenant_id: string | null
          store_id: number
          wallet_id: number
          amount: number
          operation_type: string
          description: string | null
          related_venda_id: number | null
          created_by_user_id: string | null
          employee_id: number | null
          created_at: string
        }
        Insert: {
          id?: number
          tenant_id?: string | null
          store_id: number
          wallet_id: number
          amount: number
          operation_type: string
          description?: string | null
          related_venda_id?: number | null
          created_by_user_id?: string | null
          employee_id?: number | null
          created_at?: string
        }
        Update: {
          [key: string]: any
        }
      }

      commissions: {
        Row: {
          id: number
          tenant_id: string | null
          store_id: number
          employee_id: number
          venda_id: number
          amount: number
          percentage: number | null
          status: string | null
          reversal_reason: string | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: number
          tenant_id?: string | null
          store_id: number
          employee_id: number
          venda_id: number
          amount: number
          percentage?: number | null
          status?: string | null
          reversal_reason?: string | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          status?: string | null
          reversal_reason?: string | null
          updated_at?: string
          [key: string]: any
        }
      }

      // --- CATÁLOGO ---
      products: {
        Row: {
          id: number
          store_id: number
          tenant_id: string | null
          created_at: string
          nome: string
          codigo_barras: string | null
          referencia: string | null
          tipo_produto: 'Armacao' | 'Lente' | 'LenteContato' | 'Outro' | 'Servico' | 'Tratamento'
          categoria: string | null
          marca: string | null
          preco_custo: number | null
          preco_venda: number
          margem_lucro: number | null
          estoque_atual: number
          estoque_minimo: number
          gerencia_estoque: boolean
          ncm: string | null
          cest: string | null
          cfop: string | null
          unidade_medida: string | null
          origem_mercadoria: number | null
          supplier_id: number | null
          detalhes: Json
          tem_grade: boolean
        }
        Insert: {
          id?: number
          store_id: number
          tenant_id?: string | null
          nome: string
          tipo_produto: 'Armacao' | 'Lente' | 'LenteContato' | 'Outro' | 'Servico' | 'Tratamento'
          categoria?: string | null
          marca?: string | null
          codigo_barras?: string | null
          referencia?: string | null
          preco_custo?: number | null
          preco_venda: number
          margem_lucro?: number | null
          estoque_atual?: number
          estoque_minimo?: number
          gerencia_estoque?: boolean
          ncm?: string | null
          cest?: string | null
          cfop?: string | null
          unidade_medida?: string | null
          origem_mercadoria?: number | null
          supplier_id?: number | null
          detalhes?: Json
          tem_grade?: boolean
          created_at?: string
        }
        Update: {
          id?: number
          [key: string]: any
        }
      }

      product_variants: {
        Row: {
          id: number
          product_id: number
          store_id: number
          nome_variante: string | null
          codigo_barras_especifico: string | null
          esferico: number | null
          cilindrico: number | null
          eixo: number | null
          adicao: number | null
          curva_base: number | null
          estoque_atual: number
          localizacao: string | null
          diametro: number | null
          olho: string | null
          is_sobra: boolean | null
        }
        Insert: {
          id?: number
          product_id: number
          store_id: number
          esferico?: number | null
          cilindrico?: number | null
          estoque_atual?: number
          diametro?: number | null
          olho?: string | null
          is_sobra?: boolean | null
          [key: string]: any
        }
        Update: {
          id?: number
          [key: string]: any
        }
      }

      stock_movements: {
        Row: {
          id: number
          store_id: number
          tenant_id: string | null
          created_at: string
          product_id: number | null
          variant_id: number | null
          tipo: 'Entrada' | 'Saida' | 'Perda' | 'Ajuste' | 'Devolucao' | 'Brinde'
          quantidade: number
          motivo: string | null
          custo_unitario_momento: number | null
          registrado_por_id: string | null
          related_venda_id: number | null
          related_os_id: number | null
        }
        Insert: {
          id?: number
          store_id: number
          tipo: string
          quantidade: number
          related_venda_id?: number | null
          related_os_id?: number | null
          [key: string]: any
        }
        Update: {
          [key: string]: any
        }
      }

      oftalmologistas: {
        Row: {
          id: number
          nome_completo: string
          crm: string | null
          clinica: string | null
          telefone: string | null
          email: string | null
        }
        Insert: { [key: string]: any }
        Update: { [key: string]: any }
      }

      // --- VENDAS & FINANCEIRO ---

      vendas: {
        Row: {
          id: number
          store_id: number
          customer_id: number
          employee_id: number | null
          status: 'Em Aberto' | 'Fechada' | 'Cancelada' | 'Devolvida'
          valor_total: number
          valor_desconto: number
          valor_final: number
          valor_restante: number
          financiamento_id: number | null
          created_at: string
        }
        Insert: {
          id?: number
          store_id: number
          customer_id: number
          employee_id?: number | null
          status?: 'Em Aberto' | 'Fechada' | 'Cancelada' | 'Devolvida'
          valor_total?: number
          valor_desconto?: number
          valor_final?: number
          financiamento_id?: number | null
          tenant_id?: string
          created_by_user_id?: string
        }
        Update: {
          status?: string
          financiamento_id?: number | null
          valor_desconto?: number
          [key: string]: any
        }
      }

      venda_itens: {
        Row: {
          id: number
          venda_id: number
          store_id: number
          tenant_id: string | null
          product_id: number | null
          variant_id: number | null
          item_tipo: string | null 
          descricao: string | null
          quantidade: number
          valor_unitario: number
          valor_total_item: number
          detalhes_avulsos: Json | null
        }
        Insert: {
          venda_id: number
          store_id?: number
          tenant_id?: string
          product_id?: number | null
          variant_id?: number | null
          item_tipo?: string
          descricao?: string
          quantidade: number
          valor_unitario: number
          valor_total_item: number
          detalhes_avulsos?: Json | null
        }
        Update: {
          [key: string]: any
        }
      }

      pagamentos: {
        Row: {
          id: number
          venda_id: number
          valor_pago: number
          forma_pagamento: string
          parcelas: number
          data_pagamento: string
          obs: string | null
          created_at: string
          receipt_printed_at: string | null
        }
        Insert: {
          venda_id: number
          valor_pago: number
          forma_pagamento: string
          parcelas?: number
          data_pagamento?: string
          obs?: string | null
          tenant_id?: string
          store_id?: number
          created_by_user_id?: string
          receipt_printed_at?: string
        }
        Update: {
          [key: string]: any
        }
      }

      financiamento_loja: {
        Row: {
          id: number
          venda_id: number
          customer_id: number
          valor_total_financiado: number
          valor_total: number
          quantidade_parcelas: number
          data_inicio: string
          obs: string | null
          created_at: string
          receipt_printed_at?: string
        }
        Insert: {
          venda_id: number
          customer_id: number
          valor_total_financiado: number
          quantidade_parcelas: number
          data_inicio: string
          obs?: string | null
          tenant_id?: string
          store_id?: number
          employee_id?: number
          created_by_user_id?: string
        }
        Update: {
          [key: string]: any
        }
      }

      financiamento_parcelas: {
        Row: {
          id: number
          financiamento_id: number
          numero_parcela: number
          data_vencimento: string
          valor_parcela: number
          status: string
          venda_id: number
          customer_id: number
          store_id: number
          data_pagamento: string | null
        }
        Insert: {
          financiamento_id: number
          numero_parcela: number
          data_vencimento: string
          valor_parcela: number
          status?: string
          tenant_id?: string
          store_id?: number
          customer_id?: number
        }
        Update: {
          [key: string]: any
        }
      }

      service_orders: {
        Row: {
          id: number
          venda_id: number
          created_at: string
          receita_longe_od_esferico: string | null
          receita_longe_od_cilindrico: string | null
          receita_longe_od_eixo: string | null
          receita_longe_oe_esferico: string | null
          receita_longe_oe_cilindrico: string | null
          receita_longe_oe_eixo: string | null
          receita_perto_od_esferico: string | null
          receita_perto_od_cilindrico: string | null
          receita_perto_od_eixo: string | null
          receita_perto_oe_esferico: string | null
          receita_perto_oe_cilindrico: string | null
          receita_perto_oe_eixo: string | null
          receita_adicao: string | null
          medida_dnp_od: string | null
          medida_dnp_oe: string | null
          medida_altura_od: string | null
          medida_altura_oe: string | null
          medida_horizontal: string | null
          medida_vertical: string | null
          medida_diagonal: string | null
          medida_ponte: string | null
          medida_diametro: string | null
          lab_nome: string | null
          lab_pedido_por_id: number | null
          dt_pedido_em: string | null
          dt_lente_chegou: string | null
          dt_montado_em: string | null
          dt_entregue_em: string | null
          dt_prometido_para: string | null
          obs_os: string | null
          protocolo_fisico: string | null
          dependente_id: number | null
          oftalmologista_id: number | null
          // NOVA TABELA ASSISTÊNCIA PODE TER RELAÇÃO, MAS NÃO ALTEROU OS AQUI
        }
        Insert: {
          store_id: number
          venda_id: number
          customer_id: number
          tenant_id?: string
          [key: string]: any 
        }
        Update: {
           [key: string]: any 
        }
      }
      
      venda_itens_os_links: {
        Row: {
            id: number
            service_order_id: number
            venda_item_id: number
            uso_na_os: string
        }
        Insert: {
            service_order_id: number
            venda_item_id: number
            uso_na_os: string
            tenant_id?: string
            store_id?: number
        }
        Update: {}
      }

      cobranca_historico: {
        Row: {
          id: number
          created_at: string
          tenant_id: string
          store_id: number
          customer_id: number
          venda_id: number | null
          tipo_contato: string
          resumo_conversa: string
          proxima_acao: string | null
          registrado_por_id: string
        }
        Insert: {
          id?: number
          created_at?: string
          tenant_id: string
          store_id: number
          customer_id: number
          venda_id?: number | null
          tipo_contato: string
          resumo_conversa: string
          proxima_acao?: string | null
          registrado_por_id: string
        }
        Update: {
          id?: number
          resumo_conversa?: string
          proxima_acao?: string | null
        }
      }

      caixa_diario: {
        Row: {
          id: number
          created_at: string
          tenant_id: string
          store_id: number
          aberto_por_id: string
          fechado_por_id: string | null
          data_abertura: string
          data_fechamento: string | null
          saldo_inicial: number
          saldo_final: number | null
          quebra_caixa: number | null
          status: 'Aberto' | 'Fechado'
          obs: string | null
        }
        Insert: {
          id?: number
          created_at?: string
          tenant_id?: string
          store_id: number
          aberto_por_id?: string
          fechado_por_id?: string | null
          data_abertura?: string
          data_fechamento?: string | null
          saldo_inicial: number
          saldo_final?: number | null
          quebra_caixa?: number | null
          status?: 'Aberto' | 'Fechado'
          obs?: string | null
        }
        Update: {
          id?: number
          saldo_final?: number | null
          data_fechamento?: string | null
          status?: 'Aberto' | 'Fechado'
          quebra_caixa?: number | null
          [key: string]: any
        }
      }

      caixa_movimentacoes: {
        Row: {
          id: number
          created_at: string
          tenant_id: string
          store_id: number
          caixa_id: number
          usuario_id: string
          tipo: 'Entrada' | 'Saida'
          valor: number
          descricao: string
          categoria: string | null
          forma_pagamento: string | null
        }
        Insert: {
          id?: number
          created_at?: string
          tenant_id?: string
          store_id: number
          caixa_id: number
          usuario_id?: string
          tipo: 'Entrada' | 'Saida'
          valor: number
          descricao: string
          categoria?: string | null
          forma_pagamento?: string | null
        }
        Update: {
          [key: string]: any
        }
      }
      
      // ... FIM TABLES
      post_sales: {
          Row: { id: number; status: string }
          Insert: { [key: string]: any }
          Update: { [key: string]: any }
      }
      post_sales_interactions: {
          Row: { id: number; tipo_contato: string; resumo: string; created_at: string }
          Insert: { [key: string]: any }
          Update: { [key: string]: any }
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      update_venda_financeiro: {
        Args: { p_venda_id: number }
        Returns: void
      }
      increment_stock: {
        Args: { p_product_id: number, p_quantity: number, p_new_cost: number | null }
        Returns: void
      }
    }
    Enums: {
      [_ in never]: never
    }
  }
}

==================================================
ARQUIVO: .\src\lib\utils.ts
==================================================
// Caminho: src/lib/utils.ts

export const formatCurrency = (value: number | null | undefined): string => {
  return (value || 0).toLocaleString('pt-BR', {
    style: 'currency',
    currency: 'BRL',
  })
}

==================================================
ARQUIVO: .\src\lib\actions\assistance.actions.ts
==================================================
'use server'

import { createAdminClient, getProfileByAdmin } from '@/lib/supabase/admin'
import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { z } from 'zod'
import { registrarMovimentacao } from './stock.actions'

// --- SCHEMAS ---
const AssistanceSchema = z.object({
    store_id: z.coerce.number(),
    customer_id: z.coerce.number(),
    updated_phone: z.string().optional(),
    
    product_id: z.coerce.number().optional().nullable(),
    product_descricao: z.string().min(2, "Descrição do produto obrigatória"),
    venda_original_id: z.coerce.number().optional().nullable(),
    
    descricao_defeito: z.string().min(3, "Descreva o defeito"),
    fotos_urls: z.array(z.string()).optional(),
    
    modalidade: z.enum(['Padrao', 'TrocaGarantida', 'TrocaImediata']),
})

const TimelineSchema = z.object({
    ticket_id: z.coerce.number(),
    tipo: z.string(),
    mensagem: z.string().min(2),
})

export type CreateTicketResult = {
    success: boolean
    message: string
    ticket?: any // Retorna o objeto completo para o frontend
}

// 1. CRIAR TICKET (ATUALIZADA)
export async function createAssistanceTicket(formData: FormData): Promise<CreateTicketResult> {
    const supabaseAdmin = createAdminClient()
    const { data: { user } } = await createClient().auth.getUser()
    
    if (!user) return { success: false, message: 'Usuário não autenticado.' }
    const profile = await getProfileByAdmin(user.id) as any
    if (!profile) return { success: false, message: 'Perfil inválido.' }

    const rawData = {
        store_id: formData.get('store_id'),
        customer_id: formData.get('customer_id'),
        updated_phone: formData.get('updated_phone'),
        product_id: formData.get('product_id'),
        product_descricao: formData.get('product_descricao'),
        venda_original_id: formData.get('venda_original_id'),
        descricao_defeito: formData.get('descricao_defeito'),
        modalidade: formData.get('modalidade'),
        fotos_urls: JSON.parse(formData.get('fotos_urls') as string || '[]')
    }

    const val = AssistanceSchema.safeParse(rawData)
    if (!val.success) return { success: false, message: 'Dados inválidos.' }

    const { 
        store_id, customer_id, updated_phone, product_id, product_descricao, 
        venda_original_id, descricao_defeito, modalidade, fotos_urls 
    } = val.data

    try {
        // Atualizar telefone
        if (updated_phone) {
            await (supabaseAdmin.from('customers') as any)
                .update({ fone_movel: updated_phone })
                .eq('id', customer_id)
        }

        // Criar Ticket
        const { data: ticket, error } = await (supabaseAdmin.from('assistance_tickets') as any)
            .insert({
                tenant_id: profile.tenant_id,
                store_id,
                customer_id,
                venda_original_id: venda_original_id || null,
                product_id: product_id || null,
                product_descricao,
                modalidade,
                descricao_defeito,
                fotos_urls,
                contato_usado: updated_phone,
                status: 'Triagem',
                status_publico: 'Solicitação Recebida',
                created_by_user_id: user.id
            })
            .select()
            .single()

        if (error) throw error

        await registrarTimeline(ticket.id, 'Sistema', 'Solicitação aberta.', user.id, profile.tenant_id)

        // Efeitos colaterais (Troca Imediata)
        if (modalidade === 'TrocaImediata' && product_id) {
            const fdSaida = new FormData()
            fdSaida.append('store_id', store_id.toString())
            fdSaida.append('employee_id', (profile.id || 0).toString())
            fdSaida.append('product_id', product_id.toString())
            fdSaida.append('tipo', 'Saida')
            fdSaida.append('quantidade', '1')
            fdSaida.append('motivo', `Troca Imediata Garantia Ticket #${ticket.id}`)
            
            await registrarMovimentacao({ success: false, message: '' }, fdSaida)
            await registrarTimeline(ticket.id, 'Alerta', 'Baixa de estoque realizada (Troca Imediata).', null, profile.tenant_id)
            
            await (supabaseAdmin.from('assistance_tickets') as any)
                .update({ status: 'LogisticaReversa', status_publico: 'Troca Realizada', dt_troca_cliente: new Date().toISOString() })
                .eq('id', ticket.id)
            
            ticket.status = 'LogisticaReversa' // Atualiza local para retorno
        }

        // RETORNAR DADO COMPLETO (JOIN) PARA O FRONT
        const { data: fullTicket } = await (supabaseAdmin.from('assistance_tickets') as any)
            .select('*, customers ( full_name, fone_movel )')
            .eq('id', ticket.id)
            .single()

        revalidatePath(`/dashboard/loja/${store_id}/assistencia`)
        return { success: true, message: 'Assistência aberta!', ticket: fullTicket }

    } catch (e: any) {
        return { success: false, message: e.message }
    }
}

// 2. BUSCAR TIMELINE
export async function getAssistanceTimeline(ticketId: number) {
    const supabaseAdmin = createAdminClient()
    try {
        const { data } = await (supabaseAdmin.from('assistance_timeline') as any)
            .select('*')
            .eq('ticket_id', ticketId)
            .order('created_at', { ascending: false }) // Mais recente primeiro
        return data || []
    } catch { return [] }
}

// 3. SALVAR NOVA INTERAÇÃO (TIMELINE)
export async function saveAssistanceInteraction(formData: FormData) {
    const supabaseAdmin = createAdminClient()
    const { data: { user } } = await createClient().auth.getUser()
    if (!user) return { success: false, message: 'Login necessário' }

    const profile = await getProfileByAdmin(user.id) as any
    if (!profile) return { success: false, message: 'Perfil erro' }

    const raw = {
        ticket_id: formData.get('ticket_id'),
        tipo: formData.get('tipo'),
        mensagem: formData.get('mensagem')
    }

    const val = TimelineSchema.safeParse(raw)
    if (!val.success) return { success: false, message: 'Dados inválidos' }

    try {
        await (supabaseAdmin.from('assistance_timeline') as any).insert({
            tenant_id: profile.tenant_id,
            ticket_id: val.data.ticket_id,
            tipo: val.data.tipo,
            mensagem: val.data.mensagem,
            usuario_id: user.id
        })

        revalidatePath(`/dashboard/loja/${profile.store_id}/assistencia`)
        return { success: true, message: 'Registrado.' }
    } catch (e: any) {
        return { success: false, message: e.message }
    }
}

// ... (Mantenha updateTicketStatus, getAssistanceTickets, getPublicTicket e registrarTimeline do arquivo anterior)
// Apenas garanta que registrarTimeline esteja exportada ou acessível
async function registrarTimeline(ticketId: number, tipo: string, mensagem: string, userId: string | null, tenantId: string) {
    const supabaseAdmin = createAdminClient()
    await (supabaseAdmin.from('assistance_timeline') as any).insert({
        ticket_id: ticketId,
        tenant_id: tenantId,
        tipo,
        mensagem,
        usuario_id: userId
    })
}

// (Repita as outras funções updateTicketStatus, getAssistanceTickets, etc., para o arquivo ficar completo se você for substituir tudo)
// Vou incluir as funções que já mandei antes para garantir integridade se for copy-paste
export async function updateTicketStatus(ticketId: number, novoStatus: string, storeId: number, obs?: string) {
    const supabaseAdmin = createAdminClient()
    const { data: { user } } = await createClient().auth.getUser()
    const profile = await getProfileByAdmin(user!.id) as any

    const updates: any = { status: novoStatus }
    let statusPublico = 'Em Análise'
    let mensagemLog = `Status alterado para ${novoStatus}`
    const agora = new Date().toISOString()

    switch (novoStatus) {
        case 'EmTratativa': statusPublico = 'Em Tratativa com Fabricante'; updates.dt_solicitacao_peca = agora; break;
        case 'AguardandoChegada': statusPublico = 'Aguardando Peça'; break;
        case 'AguardandoCliente': statusPublico = 'Pronto para Retirada'; updates.dt_chegada_peca = agora; mensagemLog = 'Peça chegou. Prazo de devolução iniciado.'; break;
        case 'LogisticaReversa': statusPublico = 'Em Processo de Devolução'; updates.dt_troca_cliente = agora; break;
        case 'Concluido': statusPublico = 'Finalizado'; updates.dt_conclusao = agora; updates.dt_envio_fornecedor = agora; break;
        case 'Cancelado': statusPublico = 'Cancelado'; break;
    }
    updates.status_publico = statusPublico

    try {
        await (supabaseAdmin.from('assistance_tickets') as any).update(updates).eq('id', ticketId)
        await registrarTimeline(ticketId, 'MudancaStatus', obs || mensagemLog, user!.id, profile.tenant_id)
        revalidatePath(`/dashboard/loja/${storeId}/assistencia`)
        return { success: true, message: 'Status atualizado.' }
    } catch (e: any) { return { success: false, message: e.message } }
}

export async function getAssistanceTickets(storeId: number) {
    const supabaseAdmin = createAdminClient()
    try {
        const { data } = await (supabaseAdmin.from('assistance_tickets') as any)
            .select('*, customers ( full_name, fone_movel )')
            .eq('store_id', storeId)
            .neq('status', 'Cancelado')
            .order('updated_at', { ascending: false })
        return data || []
    } catch { return [] }
}
// ARQUIVO: src/lib/actions/assistance.actions.ts (Trecho Atualizado)

export async function getPublicTicket(token: string) {
    const supabaseAdmin = createAdminClient()
    
    const { data } = await (supabaseAdmin.from('assistance_tickets') as any)
        .select(`
            status,             
            status_publico,
            product_descricao,
            dt_abertura,
            dt_solicitacao_peca,
            dt_chegada_peca,
            dt_troca_cliente,
            dt_envio_fornecedor,
            dt_conclusao,
            // ATUALIZAÇÃO: Buscando colunas extras da loja
            stores ( name, whatsapp, phone ) 
        `)
        .eq('tracking_token', token)
        .single()
        
    return data
}

==================================================
ARQUIVO: .\src\lib\actions\auth.actions.ts
==================================================
// Caminho: src/lib/actions/auth.actions.ts (CORREÇÃO DE CLIENTE ADMIN)

'use server'

import { createClient } from '@/lib/supabase/server'
import { Database } from '@/lib/database.types'
import { createAdminClient } from '@/lib/supabase/admin' // <-- IMPORTAÇÃO CORRIGIDA

type Profile = Database['public']['Tables']['profiles']['Row']

// ----------------------------------------------------
// NOVO HELPER: Busca perfil usando o cliente Admin
// ----------------------------------------------------
export async function getProfileByAdmin(userId: string) {
  try {
    const supabaseAdmin = createAdminClient()
    const { data: profile } = await (supabaseAdmin
      .from('profiles')
      .select('role, store_id, tenant_id')
      .eq('id', userId)
      .single() as any)

    return profile
  } catch (e) {
    console.error("ERRO ao buscar perfil com Service Role:", e)
    return null
  }
}
// ----------------------------------------------------


export async function getLoginRoute() {
  const supabaseRLS = createClient()
  const { data: { user } } = await supabaseRLS.auth.getUser()

  if (!user)
    return {
      success: false,
      route: '/login',
      message: 'Sessão não encontrada.',
    }

  try {
    // 1. Usa o Cliente Admin para ignorar o RLS
    const supabaseAdmin = createAdminClient()

    // 2. Busca o perfil ignorando o RLS (TIPADO COMO ANY)
    const { data: profile, error: profileError } = await (supabaseAdmin
      .from('profiles')
      .select('role, store_id, tenant_id')
      .eq('id', user.id)
      .single() as any)

    if (profileError || !profile) {
      console.error('Perfil não encontrado no roteamento:', profileError)
      return {
        success: false,
        route: '/login?error=profile_missing',
        message: 'Perfil não encontrado ou incompleto.',
      }
    }

    // 3. Lógica de Roteamento (COMPLETA)
    if (profile.role === 'admin') {
      const adminStoreId = profile.store_id || 1
      return {
        success: true,
        route: `/dashboard/loja/${adminStoreId}`,
      }
    } else if (profile.role === 'manager' || profile.role === 'store_operator') {
      if (profile.store_id) {
        return {
          success: true,
          route: `/dashboard/loja/${profile.store_id}`,
        }
      }
      return { success: true, route: '/dashboard/manager' }
    } else if (profile.role === 'vendedor') {
      return {
        success: false,
        route: '/login?error=unauthorized_role',
        message: 'Perfil de vendedor não tem acesso ao dashboard principal.',
      }
    }

    return {
      success: false,
      route: '/login?error=invalid_role',
      message: 'Cargo de usuário desconhecido.',
    }

  } catch (e) {
    console.error('Erro de Servidor no roteamento:', e)
    return {
      success: false,
      route: '/login?error=server_error',
      message: 'Erro interno do servidor.',
    }
  }
}


==================================================
ARQUIVO: .\src\lib\actions\cashflow.actions.ts
==================================================
// Caminho: src/lib/actions/cashflow.actions.ts
'use server'

import { createAdminClient, getProfileByAdmin } from '@/lib/supabase/admin'
import { createClient } from '@/lib/supabase/server'
import { Database } from '@/lib/database.types'
import { revalidatePath } from 'next/cache'
import { z } from 'zod'

type CaixaDiario = Database['public']['Tables']['caixa_diario']['Row']
type Movimentacao = Database['public']['Tables']['caixa_movimentacoes']['Row']

// --- TIPOS PARA O RESUMO ---
export type ResumoCaixa = {
    caixa: CaixaDiario | null
    movimentacoes: Movimentacao[]
    categoriasUsadas: string[] // <--- NOVO CAMPO
    vendas: {
        total_dinheiro: number
        total_pix: number
        total_cartao: number
        total_outros: number
        detalhes: any[]
    }
    totais: {
        entradas_manuais: number
        saidas_manuais: number
        saldo_esperado_dinheiro: number
        saldo_geral_acumulado: number
    }
}

// HELPER: Padronização de Texto (Primeira Maiúscula)
function formatarCategoria(texto: string | null | undefined) {
    if (!texto || texto.trim() === '') return null;
    const t = texto.trim();
    // Transforma "motoboy" em "Motoboy" e "transporte uber" em "Transporte uber"
    return t.charAt(0).toUpperCase() + t.slice(1).toLowerCase();
}

// ============================================================================
// 1. ABRIR CAIXA (VERSÃO BLINDADA CONTRA ERRO DE TENANT)
// ============================================================================
const AbrirCaixaSchema = z.object({
  store_id: z.coerce.number(),
  saldo_inicial: z.coerce.number().min(0),
})

export async function abrirCaixa(prevState: any, formData: FormData) {
  const supabase = createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return { success: false, message: 'Sessão expirada.' }

  const profile = await getProfileByAdmin(user.id) as any
  if (!profile) return { success: false, message: 'Perfil não encontrado.' }

  const val = AbrirCaixaSchema.safeParse({
    store_id: profile.store_id,
    saldo_inicial: formData.get('saldo_inicial'),
  })

  if (!val.success) {
    return { success: false, message: 'Valor inválido.' }
  }

  const supabaseAdmin = createAdminClient()

  // --- CORREÇÃO DE SEGURANÇA (FIX) ---
  // Se o perfil do usuário estiver sem tenant_id (erro de cadastro),
  // buscamos o tenant_id direto da loja para não travar o sistema.
  let finalTenantId = profile.tenant_id

  if (!finalTenantId) {
    const { data: store } = await (supabaseAdmin
      .from('stores') as any)
      .select('tenant_id')
      .eq('id', profile.store_id)
      .single()

    if (store) {
      finalTenantId = (store as any).tenant_id
    }
  }

  if (!finalTenantId) {
    return {
      success: false,
      message: 'Erro Crítico: Loja sem Tenant ID configurado. Contate o suporte.',
    }
  }
  // ------------------------------------

  // Verifica se já existe caixa aberto hoje
  const hoje = new Date()
  const dataInicioHoje = new Date(hoje.setHours(0, 0, 0, 0)).toISOString()

  const { data: existe } = await (supabaseAdmin
    .from('caixa_diario') as any)
    .select('id')
    .eq('store_id', profile.store_id)
    .eq('status', 'Aberto')
    .gte('created_at', dataInicioHoje)
    .maybeSingle()

  if (existe) {
    revalidatePath(`/dashboard/loja/${profile.store_id}/financeiro/caixa`)
    return { success: true, message: 'Caixa já estava aberto.' }
  }

  try {
    await (supabaseAdmin
      .from('caixa_diario') as any)
      .insert({
        tenant_id: finalTenantId,
        store_id: profile.store_id,
        aberto_por_id: user.id,
        data_abertura: new Date().toISOString(),
        saldo_inicial: val.data.saldo_inicial,
        status: 'Aberto',
      })

    revalidatePath(`/dashboard/loja/${profile.store_id}/financeiro/caixa`)
    return { success: true, message: 'Caixa aberto com sucesso!' }
  } catch (e: any) {
    console.error('Erro abrir caixa:', e)
    return { success: false, message: `Erro ao abrir caixa: ${e.message}` }
  }
}

// ============================================================================
// 2. LANÇAR MOVIMENTAÇÃO (ATUALIZADO COM CATEGORIA)
// ============================================================================
const MovimentoSchema = z.object({
    caixa_id: z.coerce.number(),
    tipo: z.enum(['Entrada', 'Saida']),
    valor: z.coerce.number().min(0.01),
    descricao: z.string().min(3),
    categoria: z.string().optional(),
    forma_pagamento: z.string().default('Dinheiro')
})

export async function adicionarMovimento(prevState: any, formData: FormData) {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return { success: false, message: 'Erro de permissão.' }

    const profile = await getProfileByAdmin(user.id) as any

    
    // 1. Sanitização da Categoria (Aqui acontece a mágica da padronização)
    const categoriaRaw = formData.get('categoria') as string;
    const categoriaFormatada = formatarCategoria(categoriaRaw);

    const rawData = {
        caixa_id: formData.get('caixa_id'),
        tipo: formData.get('tipo'),
        valor: formData.get('valor'),
        descricao: formData.get('descricao'),
        categoria: categoriaFormatada || undefined, // Envia formatado para validação
        forma_pagamento: formData.get('forma_pagamento') || undefined
    }

    const val = MovimentoSchema.safeParse(rawData)

    if (!val.success) {
        return { success: false, message: 'Dados inválidos. Verifique os campos.' }
    }

    const supabaseAdmin = createAdminClient()

    try {
const { error } = await (supabaseAdmin
    .from('caixa_movimentacoes') as any)
    .insert({
        tenant_id: profile?.tenant_id!,
        store_id: profile?.store_id!,
        caixa_id: val.data.caixa_id,
        usuario_id: user.id,
        tipo: val.data.tipo,
        valor: val.data.valor,
        descricao: val.data.descricao,
        categoria: val.data.categoria,
        forma_pagamento: val.data.forma_pagamento
    })

        if (error) throw error

        revalidatePath(`/dashboard/loja/${profile?.store_id}/financeiro/caixa`)
        return { success: true, message: 'Lançamento registrado.' }
    } catch (e: any) {
        return { success: false, message: e.message }
    }
}

// ============================================================================
// 3. OBTER O RESUMO DO DIA
// ============================================================================
export async function getResumoCaixa(storeId: number): Promise<ResumoCaixa | null> {
    const supabaseAdmin = createAdminClient()
    
    // 1. Buscar Caixa Aberto Hoje
    const hojeInicio = new Date()
    hojeInicio.setHours(0,0,0,0)

const { data: caixa } = await (supabaseAdmin
    .from('caixa_diario')
    .select('*')
    .eq('store_id', storeId)
    .eq('status', 'Aberto')
    .gte('created_at', hojeInicio.toISOString())
    .order('created_at', { ascending: false })
    .maybeSingle() as any)

    if (!caixa) return null 

    // 2. Buscar Movimentações Manuais
    const { data: movimentos } = await supabaseAdmin
        .from('caixa_movimentacoes')
        .select('*')
        .eq('caixa_id', caixa.id)
        .order('created_at', { ascending: false })

    const listaMov = movimentos || []

    // --- NOVO: Buscar histórico de categorias usadas recentemente ---
    // Isso alimenta o autocomplete. Pegamos os últimos 100 lançamentos da loja para extrair categorias.
    const { data: historicoCategorias } = await (supabaseAdmin
    .from('caixa_movimentacoes')
    .select('categoria')
    .eq('store_id', storeId)
    .not('categoria', 'is', null)
    .order('created_at', { ascending: false })
    .limit(100) as any)

    
    // Filtra duplicatas no JS (Set)
   // Filtra duplicatas, MAS formata antes de agrupar.
// Isso funde "transporte" e "Transporte" numa coisa só visualmente.
const categoriasUnicas = Array.from(new Set(
    historicoCategorias
        ?.map((c: any) => formatarCategoria(c.categoria))
        .filter(Boolean) as string[]
));

    // 3. BUSCAR VENDAS
    const dataReferencia = new Date(caixa.data_abertura)
    dataReferencia.setHours(0,0,0,0)

    const { data: pagamentosVendas } = await supabaseAdmin
        .from('pagamentos')
        .select('id, valor_pago, forma_pagamento, created_at')
        .eq('store_id', storeId)
        .gte('created_at', dataReferencia.toISOString()) 
    
    const listaPagamentos = pagamentosVendas || []

    // 4. CALCULAR TOTAIS
    const vendas = {
        total_dinheiro: 0,
        total_pix: 0,
        total_cartao: 0,
        total_outros: 0,
        detalhes: listaPagamentos
    }

listaPagamentos.forEach((pg: any) => {
    const valor = Number(pg.valor_pago)
    const forma = pg.forma_pagamento.toLowerCase()

    if (forma.includes('dinheiro')) vendas.total_dinheiro += valor
    else if (forma.includes('pix')) vendas.total_pix += valor
    else if (forma.includes('cart')) vendas.total_cartao += valor
    else vendas.total_outros += valor
})

const manuais = {
        entradas: 0,
        saidas: 0
    }

    listaMov.forEach((m: any) => {

        const val = Number(m.valor)
        if (m.tipo === 'Entrada') manuais.entradas += val
        else manuais.saidas += val
    })

    const saldoGaveta = 
        Number(caixa.saldo_inicial) + 
        vendas.total_dinheiro + 
        manuais.entradas - 
        manuais.saidas

    const saldoGeral = 
        saldoGaveta + 
        vendas.total_pix + 
        vendas.total_cartao + 
        vendas.total_outros

    return {
        caixa,
        movimentacoes: listaMov,
        categoriasUsadas: categoriasUnicas.sort(), // Ordena alfabeticamente para o menu
        vendas,
        totais: {
            entradas_manuais: manuais.entradas,
            saidas_manuais: manuais.saidas,
            saldo_esperado_dinheiro: saldoGaveta,
            saldo_geral_acumulado: saldoGeral
        }
    }
}

// ============================================================================
// 4. FECHAR CAIXA
// ============================================================================
export async function fecharCaixa(prevState: any, formData: FormData) {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    
    const caixaId = formData.get('caixa_id')
    const saldoFinalInformado = formData.get('saldo_final')
    const saldoEsperado = formData.get('saldo_esperado')

    const diferenca = Number(saldoFinalInformado) - Number(saldoEsperado)

    const supabaseAdmin = createAdminClient()

    try {
 await (
  supabaseAdmin
    .from('caixa_diario') as any
)
.update({
    saldo_final: Number(saldoFinalInformado),
    quebra_caixa: diferenca,
    data_fechamento: new Date().toISOString(),
    fechado_por_id: user?.id,
    status: 'Fechado'
})
.eq('id', caixaId)

        return { success: true, message: 'Caixa fechado com sucesso.' }
    } catch (e: any) {
        return { success: false, message: e.message }
    }
}

// ============================================================================
// 5. CHECAGEM RÁPIDA DE STATUS (PARA O GUARD)
// ============================================================================
export async function verificarStatusCaixa(storeId: number): Promise<boolean> {
    const supabaseAdmin = createAdminClient()
    
    const hojeInicio = new Date()
    hojeInicio.setHours(0,0,0,0)

    try {
        // Verifica se existe algum registro com status 'Aberto' criado hoje
        const { data } = await (supabaseAdmin.from('caixa_diario') as any)
            .select('id')
            .eq('store_id', storeId)
            .eq('status', 'Aberto')
            .gte('created_at', hojeInicio.toISOString())
            .maybeSingle()

        return !!data // Retorna true se achou, false se não achou
    } catch (e) {
        console.error("Erro ao verificar status do caixa:", e)
        return false // Na dúvida, assume fechado para evitar erros, ou true para não bloquear. 
                     // Aqui retornamos false para forçar a verificação visual se der erro.
    }
}

==================================================
ARQUIVO: .\src\lib\actions\catalog.actions.ts
==================================================
// ARQUIVO: src/lib/actions/catalog.actions.ts
'use server'

import { createClient } from '@/lib/supabase/server'
import { Database, Json } from '@/lib/database.types'
import { revalidatePath } from 'next/cache'
import { z } from 'zod'
import { createAdminClient, getProfileByAdmin } from '@/lib/supabase/admin'

export type CatalogActionResult = {
  success: boolean
  message: string
  errors?: Record<string, string[]>
  generatedCode?: string
}

export type CatalogItemResult = {
  id: number
  title: string
  subtitle?: string
  price?: number
  stock?: number
  raw: any 
}

// --- HELPER DE CONTEXTO ---
async function getContext() {
  const supabase = createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Usuário não autenticado')
  
  const profile: any = await getProfileByAdmin(user.id)
  
  return { user, profile, supabaseAdmin: createAdminClient() }
}

// --- HELPER: BARCODE INTELIGENTE ---
async function generateSmartBarcode(storeId: number, costPrice: number | null | undefined) {
    const supabaseAdmin = createAdminClient()
    const date = new Date()
    
    const mm = String(date.getMonth() + 1).padStart(2, '0')
    const yy = String(date.getFullYear()).slice(-2)
    const custoRaw = costPrice ? (costPrice * 100).toFixed(0) : '00000'
    const prefixo = `${mm}.${custoRaw}.${yy}.`
    
    const { count } = await supabaseAdmin
        .from('products')
        .select('*', { count: 'exact', head: true })
        .eq('store_id', storeId)
        .ilike('codigo_barras', `${prefixo}%`)

    const nextSeq = String((count || 0) + 1).padStart(3, '0')
    return `${prefixo}${nextSeq}`
}

// --- SCHEMAS ---
const LenteSchema = z.object({
  id: z.coerce.number().optional(),
  store_id: z.coerce.number(),
  nome_lente: z.string().min(2, 'Nome é obrigatório'),
  marca: z.string().optional().nullable(),
  tipo: z.string().optional().nullable(),
  material: z.string().optional().nullable(),
  indice_refracao: z.string().optional().nullable(),
  preco_custo: z.coerce.number().optional().nullable(),
  preco_venda: z.coerce.number().min(0, 'Preço obrigatório'),
})

const ArmacaoSchema = z.object({
  id: z.coerce.number().optional(),
  store_id: z.coerce.number(),
  marca: z.string().min(2, 'Marca é obrigatória'),
  modelo: z.string().optional().nullable(),
  referencia: z.string().optional().nullable(),
  cor: z.string().optional().nullable(),
  tamanho_aro: z.string().optional().nullable(),
  tamanho_ponte: z.string().optional().nullable(),
  tamanho_haste: z.string().optional().nullable(),
  preco_custo: z.coerce.number().optional().nullable(),
  preco_venda: z.coerce.number().min(0),
  quantidade_estoque: z.coerce.number().int().default(0),
  codigo_barras: z.string().optional().nullable(),
})

const TratamentoSchema = z.object({
  id: z.coerce.number().optional(),
  store_id: z.coerce.number(),
  nome_tratamento: z.string().min(2, 'Nome é obrigatório'),
  descricao: z.string().optional().nullable(),
  preco_custo_adicional: z.coerce.number().optional().nullable(),
  preco_venda_adicional: z.coerce.number().min(0),
})

const ProdutoGeralSchema = z.object({
  id: z.coerce.number().optional(),
  store_id: z.coerce.number(),
  categoria: z.string().min(2, 'Categoria é obrigatória'),
  descricao: z.string().min(2, 'Descrição é obrigatória'),
  marca: z.string().optional().nullable(),
  preco_custo: z.coerce.number().optional().nullable(),
  preco_venda: z.coerce.number().min(0),
  estoque_atual: z.coerce.number().int().default(0),
  estoque_minimo: z.coerce.number().int().default(1),
  codigo_barras: z.string().optional().nullable(),
})

const OftalmoSchema = z.object({
  id: z.coerce.number().optional(),
  store_id: z.coerce.number(),
  nome_completo: z.string().min(2, 'Nome é obrigatório'),
  crm: z.string().optional().nullable(),
  telefone: z.string().optional().nullable(),
  email: z.string().email().optional().or(z.literal('')).nullable(),
  clinica: z.string().optional().nullable(),
})

const SupplierSchema = z.object({
  id: z.coerce.number().optional(),
  store_id: z.coerce.number(),
  nome_fantasia: z.string().min(2, 'Nome Fantasia é obrigatório'),
  razao_social: z.string().optional().nullable(),
  cnpj: z.string().optional().nullable(),
  inscricao_estadual: z.string().optional().nullable(),
  telefone: z.string().optional().nullable(),
  cidade: z.string().optional().nullable(),
  uf: z.string().optional().nullable(),
})

// ============================================================================
// ACTIONS DE SALVAR (COM CORREÇÃO DE TIPAGEM 'as any')
// ============================================================================

export async function saveLente(prevState: CatalogActionResult, formData: FormData): Promise<CatalogActionResult> {
  try {
    const { profile, supabaseAdmin } = await getContext()
    const nullIfEmpty = (v: any) => (v === '' ? null : v)

    const validated = LenteSchema.safeParse({
      id: nullIfEmpty(formData.get('id')),
      store_id: profile.store_id,
      nome_lente: formData.get('nome_lente'),
      marca: nullIfEmpty(formData.get('marca')),
      tipo: nullIfEmpty(formData.get('tipo')),
      material: nullIfEmpty(formData.get('material')),
      indice_refracao: nullIfEmpty(formData.get('indice_refracao')),
      preco_custo: nullIfEmpty(formData.get('preco_custo')),
      preco_venda: formData.get('preco_venda'),
    })

    if (!validated.success) return { success: false, message: 'Erro validação', errors: validated.error.flatten().fieldErrors }
    const { id, ...data } = validated.data

    const detalhes: Json = {
        material: data.material,
        tipo_desenho: data.tipo,
        indice: data.indice_refracao
    }

    const payload = {
        tenant_id: profile.tenant_id,
        store_id: profile.store_id,
        nome: data.nome_lente,
        marca: data.marca,
        tipo_produto: 'Lente',
        categoria: 'Lente Oftálmica',
        preco_custo: data.preco_custo,
        preco_venda: data.preco_venda,
        detalhes: detalhes,
        gerencia_estoque: false,
        tem_grade: false 
    }

    if (id) {
      // CORREÇÃO: Cast para 'any' ANTES do update para ignorar verificação estrita de tipo no payload
      await (supabaseAdmin.from('products') as any)
        .update(payload)
        .eq('id', id)
    } else {
      // CORREÇÃO: Cast para 'any' ANTES do insert
      await (supabaseAdmin.from('products') as any)
        .insert(payload)
    }

    revalidatePath(`/dashboard/loja/${profile.store_id}/cadastros`)
    return { success: true, message: 'Lente salva!' }
  } catch (e: any) { return { success: false, message: e.message } }
}

export async function saveArmacao(prevState: CatalogActionResult, formData: FormData): Promise<CatalogActionResult> {
  try {
    const { profile, supabaseAdmin } = await getContext()
    const nullIfEmpty = (v: any) => (v === '' ? null : v)

    const validated = ArmacaoSchema.safeParse({
      id: nullIfEmpty(formData.get('id')),
      store_id: profile.store_id,
      marca: formData.get('marca'),
      modelo: nullIfEmpty(formData.get('modelo')),
      referencia: nullIfEmpty(formData.get('referencia')),
      cor: nullIfEmpty(formData.get('cor')),
      tamanho_aro: nullIfEmpty(formData.get('tamanho_aro')),
      tamanho_ponte: nullIfEmpty(formData.get('tamanho_ponte')),
      tamanho_haste: nullIfEmpty(formData.get('tamanho_haste')),
      preco_custo: nullIfEmpty(formData.get('preco_custo')),
      preco_venda: formData.get('preco_venda'),
      quantidade_estoque: formData.get('quantidade_estoque'),
      codigo_barras: nullIfEmpty(formData.get('codigo_barras')),
    })

    if (!validated.success) return { success: false, message: 'Erro validação', errors: validated.error.flatten().fieldErrors }
    const { id, ...data } = validated.data

    let finalBarcode = data.codigo_barras
    if (!finalBarcode) finalBarcode = await generateSmartBarcode(profile.store_id, data.preco_custo)

    const detalhes: Json = {
        modelo: data.modelo,
        cor: data.cor,
        aro: data.tamanho_aro,
        ponte: data.tamanho_ponte,
        haste: data.tamanho_haste
    }

    const payload = {
        tenant_id: profile.tenant_id,
        store_id: profile.store_id,
        nome: `${data.marca} ${data.modelo || ''} ${data.referencia || ''}`.trim(),
        marca: data.marca,
        referencia: data.referencia,
        codigo_barras: finalBarcode,
        tipo_produto: 'Armacao',
        categoria: 'Armação',
        preco_custo: data.preco_custo,
        preco_venda: data.preco_venda,
        estoque_atual: data.quantidade_estoque,
        gerencia_estoque: true,
        detalhes: detalhes
    }

    if (id) {
        await (supabaseAdmin.from('products') as any).update(payload).eq('id', id)
    } else {
        await (supabaseAdmin.from('products') as any).insert(payload)
    }

    revalidatePath(`/dashboard/loja/${profile.store_id}/cadastros`)
    return { success: true, message: `Armação salva! Cód: ${finalBarcode}`, generatedCode: finalBarcode || undefined }
  } catch (e: any) { return { success: false, message: e.message } }
}

export async function saveProdutoGeral(prevState: CatalogActionResult, formData: FormData): Promise<CatalogActionResult> {
  try {
    const { profile, supabaseAdmin } = await getContext()
    const nullIfEmpty = (v: any) => (v === '' ? null : v)

    const validated = ProdutoGeralSchema.safeParse({
      id: nullIfEmpty(formData.get('id')),
      store_id: profile.store_id,
      categoria: formData.get('categoria'),
      descricao: formData.get('descricao'),
      marca: nullIfEmpty(formData.get('marca')),
      preco_custo: nullIfEmpty(formData.get('preco_custo')),
      preco_venda: formData.get('preco_venda'),
      estoque_atual: formData.get('estoque_atual'),
      estoque_minimo: formData.get('estoque_minimo'),
      codigo_barras: nullIfEmpty(formData.get('codigo_barras')),
    })

    if (!validated.success) return { success: false, message: 'Erro validação', errors: validated.error.flatten().fieldErrors }
    const { id, ...data } = validated.data

    let finalBarcode = data.codigo_barras
    if (!finalBarcode) finalBarcode = await generateSmartBarcode(profile.store_id, data.preco_custo)

    const payload = {
        tenant_id: profile.tenant_id,
        store_id: profile.store_id,
        nome: data.descricao,
        marca: data.marca,
        codigo_barras: finalBarcode,
        tipo_produto: 'Outro',
        categoria: data.categoria,
        preco_custo: data.preco_custo,
        preco_venda: data.preco_venda,
        estoque_atual: data.estoque_atual,
        estoque_minimo: data.estoque_minimo,
        gerencia_estoque: true
    }

    if (id) {
        await (supabaseAdmin.from('products') as any).update(payload).eq('id', id)
    } else {
        await (supabaseAdmin.from('products') as any).insert(payload)
    }

    revalidatePath(`/dashboard/loja/${profile.store_id}/cadastros`)
    return { success: true, message: `Produto salvo! Cód: ${finalBarcode}`, generatedCode: finalBarcode || undefined }
  } catch (e: any) { return { success: false, message: e.message } }
}

export async function saveTratamento(prevState: CatalogActionResult, formData: FormData): Promise<CatalogActionResult> {
  try {
    const { profile, supabaseAdmin } = await getContext()
    const nullIfEmpty = (v: any) => (v === '' ? null : v)
    
    const validated = TratamentoSchema.safeParse({
      id: nullIfEmpty(formData.get('id')),
      store_id: profile.store_id,
      nome_tratamento: formData.get('nome_tratamento'),
      descricao: nullIfEmpty(formData.get('descricao')),
      preco_custo_adicional: nullIfEmpty(formData.get('preco_custo_adicional')),
      preco_venda_adicional: formData.get('preco_venda_adicional'),
    })

    if (!validated.success) return { success: false, message: 'Erro validação', errors: validated.error.flatten().fieldErrors }
    const { id, ...data } = validated.data

    const payload = {
        tenant_id: profile.tenant_id,
        store_id: profile.store_id,
        nome: data.nome_tratamento,
        tipo_produto: 'Tratamento',
        categoria: 'Tratamento de Lente',
        preco_custo: data.preco_custo_adicional,
        preco_venda: data.preco_venda_adicional,
        detalhes: { descricao: data.descricao }
    }

    if (id) {
        await (supabaseAdmin.from('products') as any).update(payload).eq('id', id)
    } else {
        await (supabaseAdmin.from('products') as any).insert(payload)
    }

    revalidatePath(`/dashboard/loja/${profile.store_id}/cadastros`)
    return { success: true, message: 'Tratamento salvo!' }
  } catch (e: any) { return { success: false, message: e.message } }
}

export async function saveOftalmo(prevState: CatalogActionResult, formData: FormData): Promise<CatalogActionResult> {
  try {
    const { profile, supabaseAdmin } = await getContext()
    const nullIfEmpty = (v: any) => (v === '' ? null : v)
    const validated = OftalmoSchema.safeParse({
      id: nullIfEmpty(formData.get('id')),
      store_id: profile.store_id,
      nome_completo: formData.get('nome_completo'),
      crm: nullIfEmpty(formData.get('crm')),
      telefone: nullIfEmpty(formData.get('telefone')),
      email: nullIfEmpty(formData.get('email')),
      clinica: nullIfEmpty(formData.get('clinica')),
    })
    if (!validated.success) return { success: false, message: 'Erro validação', errors: validated.error.flatten().fieldErrors }
    const { id, ...data } = validated.data
    
    // Cast as any aqui também por garantia
    if (id) await (supabaseAdmin.from('oftalmologistas') as any).update(data).eq('id', id)
    else await (supabaseAdmin.from('oftalmologistas') as any).insert({ ...data, tenant_id: profile.tenant_id })

    revalidatePath(`/dashboard/loja/${profile.store_id}/cadastros`)
    return { success: true, message: 'Oftalmologista salvo!' }
  } catch (e: any) { return { success: false, message: e.message } }
}

// --- SALVAR FORNECEDOR (NOVO) ---
export async function saveSupplier(prevState: CatalogActionResult, formData: FormData): Promise<CatalogActionResult> {
  try {
    const { profile, supabaseAdmin } = await getContext()
    const nullIfEmpty = (v: any) => (v === '' ? null : v)
    
    const validated = SupplierSchema.safeParse({
      id: nullIfEmpty(formData.get('id')),
      store_id: profile.store_id,
      nome_fantasia: formData.get('nome_fantasia'),
      razao_social: nullIfEmpty(formData.get('razao_social')),
      cnpj: nullIfEmpty(formData.get('cnpj')),
      inscricao_estadual: nullIfEmpty(formData.get('inscricao_estadual')),
      telefone: nullIfEmpty(formData.get('telefone')),
      cidade: nullIfEmpty(formData.get('cidade')),
      uf: nullIfEmpty(formData.get('uf')),
    })

    if (!validated.success) return { success: false, message: 'Erro validação', errors: validated.error.flatten().fieldErrors }
    const { id, ...data } = validated.data
    
    const payload = { ...data, tenant_id: profile.tenant_id }

    // Cast 'as any' para evitar erro de tipo no build do Vercel
    let error;
    if (id) {
       const res = await (supabaseAdmin.from('suppliers') as any).update(payload).eq('id', id)
       error = res.error
    } else {
        const res = await (supabaseAdmin.from('suppliers') as any).insert(payload)
        error = res.error
    }

    if (error) throw new Error(error.message)

    revalidatePath(`/dashboard/loja/${profile.store_id}/cadastros`)
    return { success: true, message: 'Fornecedor salvo!' }
  } catch (e: any) { 
      console.error("Erro ao salvar fornecedor:", e)
      return { success: false, message: `Erro ao salvar: ${e.message}` } 
  }
}

// ============================================================================
// ACTION DE DELETAR
// ============================================================================
export async function deleteCatalogItem(
  id: number, 
  storeId: number, 
  categoryContext: 'lentes' | 'armacoes' | 'tratamentos' | 'oftalmologistas' | 'produtos_gerais' | 'fornecedores'
): Promise<CatalogActionResult> {
  try {
    const supabaseAdmin = createAdminClient()
    
    if (categoryContext === 'oftalmologistas') {
        await (supabaseAdmin.from('oftalmologistas') as any).delete().eq('id', id)
    } else if (categoryContext === 'fornecedores') {
        await (supabaseAdmin.from('suppliers') as any).delete().eq('id', id)
    } else {
        await (supabaseAdmin.from('products') as any).delete().eq('id', id)
    }
    
    revalidatePath(`/dashboard/loja/${storeId}/cadastros`)
    return { success: true, message: 'Item deletado.' }
  } catch (e: any) { return { success: false, message: e.message } }
}

// ============================================================================
// ACTION DE BUSCA
// ============================================================================
export async function fetchCatalogItems(
  storeId: number, 
  category: 'lentes' | 'armacoes' | 'tratamentos' | 'oftalmologistas' | 'produtos_gerais' | 'fornecedores',
  query: string = ''
): Promise<CatalogItemResult[]> {
  
  const supabaseAdmin = createAdminClient()

  if (category === 'oftalmologistas') {
      let q = (supabaseAdmin.from('oftalmologistas') as any).select('*').eq('store_id', storeId).limit(50)
      if (query) q = q.ilike('nome_completo', `%${query}%`)
      const { data } = await q.order('nome_completo')
      return (data || []).map((i: any) => ({
          id: i.id, title: i.nome_completo, subtitle: i.crm ? `CRM: ${i.crm}` : i.clinica, raw: i
      }))
  }

  if (category === 'fornecedores') {
      let q = (supabaseAdmin.from('suppliers') as any).select('*').eq('store_id', storeId).limit(50)
      if (query) q = q.ilike('nome_fantasia', `%${query}%`)
      
      const { data } = await q.order('nome_fantasia')
      return (data || []).map((i: any) => ({
          id: i.id, 
          title: i.nome_fantasia, 
          subtitle: i.cnpj || i.cidade, 
          raw: i 
      }))
  }

  let tipoFiltro = ''
  if (category === 'lentes') tipoFiltro = 'Lente'
  else if (category === 'armacoes') tipoFiltro = 'Armacao'
  else if (category === 'tratamentos') tipoFiltro = 'Tratamento'
  else if (category === 'produtos_gerais') tipoFiltro = 'Outro'

  let q = (supabaseAdmin.from('products') as any)
    .select('*')
    .eq('store_id', storeId)
    // Cast as any aqui garante que o TS não reclame do enum se o arquivo de tipos estiver desatualizado
    .eq('tipo_produto', tipoFiltro as any)
    .limit(50)

  if (query) {
      q = q.or(`nome.ilike.%${query}%,codigo_barras.eq.${query},referencia.ilike.%${query}%`)
  }

  const { data } = await q.order('created_at', { ascending: false })
  if (!data) return []

  return data.map((p: any) => {
      const d = (p.detalhes as any) || {}
      
      let rawData: any = { id: p.id, preco_venda: p.preco_venda, preco_custo: p.preco_custo }
      
      if (category === 'lentes') {
          rawData = { ...rawData, nome_lente: p.nome, marca: p.marca, tipo: d.tipo_desenho, material: d.material, indice_refracao: d.indice }
          return { id: p.id, title: p.nome, subtitle: `${p.marca || ''} ${d.material || ''}`, price: p.preco_venda, raw: rawData }
      }
      
      if (category === 'armacoes') {
          rawData = { 
              ...rawData, marca: p.marca, referencia: p.referencia, codigo_barras: p.codigo_barras, quantidade_estoque: p.estoque_atual,
              modelo: d.modelo, cor: d.cor, tamanho_aro: d.aro, tamanho_ponte: d.ponte, tamanho_haste: d.haste 
          }
          return { id: p.id, title: p.nome, subtitle: p.codigo_barras ? `Cód: ${p.codigo_barras}` : `Ref: ${p.referencia}`, price: p.preco_venda, stock: p.estoque_atual, raw: rawData }
      }

      if (category === 'produtos_gerais') {
          rawData = { ...rawData, descricao: p.nome, categoria: p.categoria, marca: p.marca, estoque_atual: p.estoque_atual, estoque_minimo: p.estoque_minimo, codigo_barras: p.codigo_barras }
          return { id: p.id, title: p.nome, subtitle: `Cat: ${p.categoria}`, price: p.preco_venda, stock: p.estoque_atual, raw: rawData }
      }

      if (category === 'tratamentos') {
          rawData = { ...rawData, nome_tratamento: p.nome, descricao: d.descricao, preco_venda_adicional: p.preco_venda, preco_custo_adicional: p.preco_custo }
          return { id: p.id, title: p.nome, subtitle: d.descricao, price: p.preco_venda, raw: rawData }
      }

      return { id: p.id, title: p.nome, raw: p }
  })
}

// Helper Categorias
export async function fetchCategoriasProdutos(storeId: number) {
    const supabaseAdmin = createAdminClient()
    const { data } = await (supabaseAdmin.from('products') as any)
        .select('categoria')
        .eq('store_id', storeId)
        .eq('tipo_produto', 'Outro')
        .order('categoria')
    
    return Array.from(new Set(data?.map((i: any) => i.categoria).filter(Boolean) as string[]))
}

==================================================
ARQUIVO: .\src\lib\actions\collection.actions.ts
==================================================
// Caminho: src/lib/actions/collection.actions.ts
'use server'

import { createAdminClient, getProfileByAdmin } from '@/lib/supabase/admin'
import { createClient } from '@/lib/supabase/server'
import { Database } from '@/lib/database.types'
import { revalidatePath } from 'next/cache'
import { z } from 'zod'

// --- Tipos ---
export type DevedorResumo = {
  customer_id: number
  full_name: string
  fone_movel: string | null
  is_spc: boolean
  total_atrasado: number
  dias_atraso: number
  quantidade_parcelas_atrasadas: number
  vendas_afetadas: number[]
}

export type CobrancaHistoricoItem = Database['public']['Tables']['cobranca_historico']['Row']

// --- 1. BUSCAR LISTA DE INADIMPLENTES ---
export async function getInadimplentes(storeId: number, filtro: 'todos' | 'sem_spc' = 'todos') {
  const supabaseAdmin = createAdminClient()
  const hoje = new Date().toISOString().split('T')[0]

  try {
    // CORREÇÃO: Cast "as any" para evitar erro de tipagem nos joins complexos ou campos novos
    let query = (supabaseAdmin
      .from('financiamento_parcelas') as any)
      .select(`
        id,
        valor_parcela,
        data_vencimento,
        customer_id,
        status,
        financiamento_loja ( venda_id ), 
        customers!inner ( id, full_name, fone_movel, is_spc )
      `)
      .eq('store_id', storeId)
      .eq('status', 'Pendente')
      .lt('data_vencimento', hoje)
      .order('data_vencimento', { ascending: true })

    if (filtro === 'sem_spc') {
      // is_spc foi adicionado manualmente, o TS pode não reconhecer sem o cast anterior
      query = query.is('customers.is_spc', false)
    }

    const { data, error } = await query

    if (error) throw error
    if (!data) return []

    const mapaClientes = new Map<number, DevedorResumo>()

    data.forEach((parcela: any) => {
        const cust = parcela.customers
        if (!cust) return;

        // O ID da venda vem do objeto aninhado
        const vendaId = parcela.financiamento_loja?.venda_id;

        const vencimento = new Date(parcela.data_vencimento)
        const hojeDate = new Date()
      
        const diffTime = Math.abs(hojeDate.getTime() - vencimento.getTime())
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24))

        if (!mapaClientes.has(cust.id)) {
            mapaClientes.set(cust.id, {
                customer_id: cust.id,
                full_name: cust.full_name,
                fone_movel: cust.fone_movel,
                is_spc: cust.is_spc ?? false,
                total_atrasado: 0,
                dias_atraso: 0,
                quantidade_parcelas_atrasadas: 0,
                vendas_afetadas: []
            })
        }

        const current = mapaClientes.get(cust.id)!
        current.total_atrasado += parcela.valor_parcela
        current.quantidade_parcelas_atrasadas += 1
        
        if (diffDays > current.dias_atraso) current.dias_atraso = diffDays
        
        if (vendaId && !current.vendas_afetadas.includes(vendaId)) {
            current.vendas_afetadas.push(vendaId)
        }
    })

    return Array.from(mapaClientes.values()).sort((a, b) => b.dias_atraso - a.dias_atraso)

  } catch (error: any) {
    console.error('Erro ao buscar inadimplentes:', error)
    return []
  }
}

// --- 2. REGISTRAR CONTATO (HISTÓRICO) ---
const CobrancaSchema = z.object({
    customer_id: z.coerce.number(),
    store_id: z.coerce.number(),
    venda_id: z.coerce.number().optional().nullable(),
    tipo_contato: z.string().min(1),
    resumo: z.string().min(3),
    proxima_acao: z.string().optional().nullable()
})

export async function registrarCobranca(prevState: any, formData: FormData) {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return { success: false, message: 'Usuário não logado' }

    type SimpleProfile = {
      store_id: number
      tenant_id: string | null
    }

    const profile = (await getProfileByAdmin(user.id)) as SimpleProfile | null

    if (!profile) {
      return { success: false, message: 'Perfil não encontrado' }
    }

    const validated = CobrancaSchema.safeParse({
        customer_id: formData.get('customer_id'),
        store_id: profile.store_id,
        venda_id: formData.get('venda_id'),
        tipo_contato: formData.get('tipo_contato'),
        resumo: formData.get('resumo'),
        proxima_acao: formData.get('proxima_acao') || null
    })

    if (!validated.success) return { success: false, message: 'Dados inválidos' }

    const supabaseAdmin = createAdminClient()
    
    try {
        // CORREÇÃO: Cast as any para permitir insert em cobranca_historico sem validação estrita
        await (supabaseAdmin.from('cobranca_historico') as any).insert({
            tenant_id: profile.tenant_id,
            store_id: profile.store_id,
            registrado_por_id: user.id,
            customer_id: validated.data.customer_id,
            venda_id: validated.data.venda_id,
            tipo_contato: validated.data.tipo_contato,
            resumo_conversa: validated.data.resumo,
            proxima_acao: validated.data.proxima_acao
        })

        revalidatePath(`/dashboard/loja/${profile.store_id}/cobranca`)
        return { success: true, message: 'Contato registrado!' }
    } catch (e: any) {
        return { success: false, message: e.message }
    }
}

// --- 3. TOGGLE SPC ---
export async function toggleSpcStatus(customerId: number, currentStatus: boolean, storeId: number) {
    const supabaseAdmin = createAdminClient()
    try {
        // CORREÇÃO: Cast as any pois is_spc foi adicionado via SQL manual
        await (supabaseAdmin.from('customers') as any)
            .update({ is_spc: !currentStatus })
            .eq('id', customerId)
        
        revalidatePath(`/dashboard/loja/${storeId}/cobranca`)
        return { success: true, message: `Cliente ${!currentStatus ? 'adicionado ao' : 'removido do'} SPC.` }
    } catch (e: any) {
        return { success: false, message: e.message }
    }
}

// --- 4. BUSCAR HISTÓRICO ---
export async function getHistoricoCobranca(customerId: number) {
    const supabaseAdmin = createAdminClient()
    try {
        // CORREÇÃO: Cast as any para tabela de cobrança
        const { data } = await (supabaseAdmin.from('cobranca_historico') as any)
            .select('*')
            .eq('customer_id', customerId)
            .order('created_at', { ascending: false })
        
        return data || []
    } catch (e) {
        return []
    }
}

// --- 5. BUSCAR DETALHES COMPLETOS ---
export async function getDetalhesDivida(customerId: number, storeId: number) {
    const supabaseAdmin = createAdminClient()
    
    try {
        // CORREÇÃO: Cast as any para permitir os joins complexos que podem não estar nos tipos locais
        const { data: financiamentos, error } = await (supabaseAdmin.from('financiamento_loja') as any)
            .select(`
                id,
                created_at,
                valor_total:valor_total_financiado,
                quantidade_parcelas,
                venda_id,
                vendas!financiamento_loja_venda_id_fkey (
                    id,
                    created_at,
                    valor_final,
                    venda_itens ( descricao, quantidade, valor_total_item )
                ),
                financiamento_parcelas (
                    id,
                    numero_parcela,
                    data_vencimento,
                    valor_parcela,
                    status,
                    data_pagamento
                )
            `)
            .eq('customer_id', customerId)
            .eq('store_id', storeId)
            .order('created_at', { ascending: false })

        if (error) throw error

        return financiamentos || []
    } catch (e) {
        console.error("Erro ao buscar detalhes:", e)
        return []
    }
}

==================================================
ARQUIVO: .\src\lib\actions\commission.actions.ts
==================================================
// Caminho: src/lib/actions/commission.actions.ts
'use server'

import { createAdminClient } from '@/lib/supabase/admin'
import { revalidatePath } from 'next/cache'

// --- CÁLCULO AUTOMÁTICO ---
export async function calcularERegistrarComissao(vendaId: number) {
    const supabase = createAdminClient()

    try {
        // CORREÇÃO: Cast as any para acessar colunas de comissão que podem não estar nos tipos
        const { data: venda, error } = await (supabase
            .from('vendas') as any)
            .select(`
                *,
                venda_itens ( valor_total_item, product_id, produtos:products(preco_custo) ),
                pagamentos ( valor_pago, forma_pagamento ),
                employees ( 
                    id, 
                    comm_rate_guaranteed, 
                    comm_rate_store_credit, 
                    comm_rate_profit 
                )
            `)
            .eq('id', vendaId)
            .single()

        if (error || !venda || !venda.employee_id || !venda.employees) {
            return 
        }

        const emp = venda.employees as any 
        const valorVenda = venda.valor_final 

        const rateGuaranteed = emp.comm_rate_guaranteed || 0
        const rateCredit = emp.comm_rate_store_credit || 0
        const rateProfit = emp.comm_rate_profit || 0

        if (rateGuaranteed === 0 && rateCredit === 0 && rateProfit === 0) {
            return 
        }

        let comissaoTotal = 0

        // A. POR PAGAMENTO
        const totalPagoGarantido = venda.pagamentos?.reduce((acc: number, pg: any) => {
            const forma = (pg.forma_pagamento || '').toLowerCase()
            if (forma.includes('pix') || forma.includes('dinheiro') || forma.includes('cart') || forma.includes('débito')) {
                return acc + (pg.valor_pago || 0)
            }
            return acc
        }, 0) || 0

        const totalRisco = valorVenda - totalPagoGarantido

        if (totalPagoGarantido > 0 && rateGuaranteed > 0) {
            comissaoTotal += totalPagoGarantido * (rateGuaranteed / 100)
        }

        if (totalRisco > 0 && rateCredit > 0) {
            comissaoTotal += totalRisco * (rateCredit / 100)
        }

        // B. SOBRE LUCRO
        if (rateProfit > 0) {
            const custoTotal = venda.venda_itens?.reduce((acc: number, item: any) => {
                const custoUnit = item.produtos?.preco_custo || 0
                return acc + (custoUnit * (item.quantidade || 1))
            }, 0) || 0

            const lucroBruto = valorVenda - custoTotal
            
            if (lucroBruto > 0) {
                comissaoTotal += lucroBruto * (rateProfit / 100)
            }
        }

        // GRAVAÇÃO
        if (comissaoTotal > 0) {
            // CORREÇÃO: Cast as any para insert/delete em commissions
            await (supabase.from('commissions') as any).delete().eq('venda_id', vendaId)

            await (supabase.from('commissions') as any).insert({
                tenant_id: venda.tenant_id,
                store_id: venda.store_id,
                employee_id: venda.employee_id,
                venda_id: vendaId,
                amount: parseFloat(comissaoTotal.toFixed(2)),
                status: 'Pendente', 
                created_at: new Date().toISOString()
            })
        }

    } catch (e: any) {
        console.error("Erro silencioso ao calcular comissão:", e)
    }
}

export async function cancelarComissao(vendaId: number) {
    const supabase = createAdminClient()
    try {
        // CORREÇÃO: Cast as any para update em commissions
        await (supabase
            .from('commissions') as any)
            .update({ status: 'Cancelado', reversal_reason: 'Venda Cancelada' })
            .eq('venda_id', vendaId)
    } catch (e) {
        console.error("Erro silencioso ao cancelar comissão:", e)
    }
}

// --- NOVO: RELATÓRIOS E PAGAMENTO ---

export type ResumoComissao = {
    employee_id: number
    employee_name: string
    total_vendas: number
    comissao_pendente: number
    comissao_paga: number
    detalhes: any[]
}

export async function getRelatorioComissoes(storeId: number, inicio: string, fim: string) {
    const supabase = createAdminClient()
    
    // Ajusta o fim para cobrir o dia todo
    const dataFim = new Date(fim)
    dataFim.setHours(23, 59, 59, 999)

    try {
        // CORREÇÃO: Cast as any para select com joins e filtros
        const { data: comissoes, error } = await (supabase
            .from('commissions') as any)
            .select(`
                id, amount, status, created_at, venda_id,
                employees ( id, full_name ),
                vendas ( valor_final, created_at )
            `)
            .eq('store_id', storeId)
            .neq('status', 'Cancelado') // Ignora canceladas
            .gte('created_at', inicio)
            .lte('created_at', dataFim.toISOString())
            .order('created_at', { ascending: false })

        if (error) throw error
        
        // Agrupamento manual (Supabase não tem Group By fácil no client)
        const mapa = new Map<number, ResumoComissao>()

        comissoes?.forEach((c: any) => {
            const empId = c.employees.id
            const empName = c.employees.full_name
            const valor = c.amount
            const isPago = c.status === 'Pago'

            if (!mapa.has(empId)) {
                mapa.set(empId, {
                    employee_id: empId,
                    employee_name: empName,
                    total_vendas: 0,
                    comissao_pendente: 0,
                    comissao_paga: 0,
                    detalhes: []
                })
            }

            const resumo = mapa.get(empId)!
            
            if (isPago) resumo.comissao_paga += valor
            else resumo.comissao_pendente += valor
            
            // Só soma no total de vendas se for um registro único de venda (para não duplicar se tiver ajustes futuros)
            // Aqui simplificamos: assumimos que 1 comissão = 1 venda
            resumo.total_vendas += (c.vendas?.valor_final || 0)

            resumo.detalhes.push({
                id: c.id,
                data: c.created_at,
                venda_id: c.venda_id,
                valor_venda: c.vendas?.valor_final,
                valor_comissao: valor,
                status: c.status
            })
        })

        return { success: true, data: Array.from(mapa.values()) }

    } catch (e: any) {
        console.error("Erro ao buscar relatório:", e)
        return { success: false, message: e.message }
    }
}

export async function pagarComissoesEmLote(
    storeId: number, 
    employeeId: number, 
    idsComissoes: number[]
) {
    const supabase = createAdminClient()
    
    try {
        // 1. Atualiza status
        // CORREÇÃO: Cast as any para update em lote
        const { error } = await (supabase
            .from('commissions') as any)
            .update({ 
                status: 'Pago', 
                updated_at: new Date().toISOString() 
            })
            .in('id', idsComissoes)
            .eq('status', 'Pendente') // Segurança: só paga o que está pendente

        if (error) throw error

        revalidatePath(`/dashboard/loja/${storeId}/financeiro/comissoes`)
        return { success: true, message: 'Pagamento registrado com sucesso!' }

    } catch (e: any) {
        return { success: false, message: e.message }
    }
}

==================================================
ARQUIVO: .\src\lib\actions\consultas.actions.ts
==================================================
// Caminho: src/lib/actions/consultas.actions.ts
'use server'

import { createAdminClient } from '@/lib/supabase/admin'

export type AlertaEntrega = {
    id: number
    created_at: string
    dt_prometido_para: string
    customer_name: string
    venda_id: number
}

export type AlertaLaboratorio = {
    id: number
    created_at: string
    tempo_decorrido_horas: number
    customer_name: string
    venda_id: number
}

// ATUALIZADO: Inclui a contagem de vendas
export type DashboardAlerts = {
    entregas: AlertaEntrega[]
    laboratorio: AlertaLaboratorio[]
    vendasEmAberto: number 
}

export async function getAlertasOperacionais(storeId: number): Promise<DashboardAlerts> {
    const supabaseAdmin = createAdminClient()
    const hoje = new Date()
    const amanha = new Date(hoje)
    amanha.setDate(hoje.getDate() + 1)
    const ontem = new Date(hoje.getTime() - (24 * 60 * 60 * 1000)).toISOString()

    try {
        // 1. Buscas Paralelas para otimizar tempo
        const [resEntrega, resLab, resVendas] = await Promise.all([
            // Entregas (Cast as any para evitar erro de relacionamento aninhado)
            (supabaseAdmin
                .from('service_orders') as any)
                .select('id, created_at, dt_prometido_para, venda_id, customers(full_name)')
                .eq('store_id', storeId)
                .is('dt_entregue_em', null)
                .lte('dt_prometido_para', amanha.toISOString())
                .order('dt_prometido_para', { ascending: true }),
            
            // Laboratório (Parado > 24h sem pedido)
            (supabaseAdmin
                .from('service_orders') as any)
                .select('id, created_at, venda_id, customers(full_name)')
                .eq('store_id', storeId)
                .is('dt_pedido_em', null)
                .lt('created_at', ontem)
                .order('created_at', { ascending: true }),

            // Contagem de Vendas em Aberto
            (supabaseAdmin
                .from('vendas') as any)
                .select('*', { count: 'exact', head: true }) // head: true traz só a contagem
                .eq('store_id', storeId)
                .eq('status', 'Em Aberto')
        ])

        // Processamento Entregas
        const entregas: AlertaEntrega[] = (resEntrega.data || []).map((item: any) => ({
            id: item.id,
            created_at: item.created_at,
            dt_prometido_para: item.dt_prometido_para,
            customer_name: item.customers?.full_name || 'Cliente Desconhecido',
            venda_id: item.venda_id
        }))

        // Processamento Laboratório
        const laboratorio: AlertaLaboratorio[] = (resLab.data || []).map((item: any) => {
            const criado = new Date(item.created_at).getTime()
            const horas = Math.floor((hoje.getTime() - criado) / (1000 * 60 * 60))
            return {
                id: item.id,
                created_at: item.created_at,
                tempo_decorrido_horas: horas,
                customer_name: item.customers?.full_name || 'Cliente Desconhecido',
                venda_id: item.venda_id
            }
        })

        return { 
            entregas, 
            laboratorio,
            vendasEmAberto: resVendas.count || 0 
        }

    } catch (error) {
        console.error("Erro ao buscar alertas:", error)
        return { entregas: [], laboratorio: [], vendasEmAberto: 0 }
    }
}

export type ResultadoBusca = {
    clientes: { id: number; nome: string; cpf: string | null; fone: string | null }[]
    vendas: { id: number; data: string; valor: number; status: string; cliente: string }[]
    os: { id: number; venda_id: number | null; protocolo: string | null; data: string; cliente: string; status: string }[]
    produtos: { id: number; tipo: string; nome: string; preco: number; estoque: number; codigo: string | null }[]
}

export async function realizarBuscaUniversal(termo: string, storeId: number): Promise<ResultadoBusca> {
    const supabaseAdmin = createAdminClient()
    const cleanTerm = termo.trim()
    
    const resultados: ResultadoBusca = { clientes: [], vendas: [], os: [], produtos: [] }
    
    if (!cleanTerm) return resultados

    try {
        const isNumeric = /^\d+$/.test(cleanTerm)
        
        // --- PASSO ZERO: DETECTA DEPENDENTES ---
        let dependenteIds: number[] = []
        let responsavelIds: number[] = []
        let mapaDependenteNome = new Map<number, string>()

        if (!isNumeric) {
            // CORREÇÃO: Cast as any
            const { data: deps } = await (supabaseAdmin.from('dependentes') as any)
                .select('id, customer_id, full_name')
                .eq('store_id', storeId)
                .ilike('full_name', `%${cleanTerm}%`)
                .limit(5)
            
            if (deps && deps.length > 0) {
                deps.forEach((d: any) => {
                    dependenteIds.push(d.id)
                    responsavelIds.push(d.customer_id)
                    mapaDependenteNome.set(d.customer_id, d.full_name)
                })
            }
        }

        // --- 1. BUSCAR CLIENTES ---
        const promisesClientes = []
        
        // CORREÇÃO: Cast as any na query base de clientes
        let queryA = (supabaseAdmin
            .from('customers') as any)
            .select('id, full_name, cpf, fone_movel')
            .eq('store_id', storeId)
            .limit(5)

        if (isNumeric) {
            queryA = queryA.or(`cpf.ilike.%${cleanTerm}%,fone_movel.ilike.%${cleanTerm}%`)
        } else {
            queryA = queryA.ilike('full_name', `%${cleanTerm}%`)
        }
        promisesClientes.push(queryA)

        if (responsavelIds.length > 0) {
            promisesClientes.push(
                (supabaseAdmin.from('customers') as any)
                    .select('id, full_name, cpf, fone_movel')
                    .in('id', responsavelIds)
            )
        }

        const resultadosClientes = await Promise.all(promisesClientes as any)
        const todosClientes = resultadosClientes.flatMap((r: any) => r.data || [])
        
        const mapClientesUnicos = new Map()
        todosClientes.forEach((c: any) => {
            if (!mapClientesUnicos.has(c.id)) {
                const nomeDependente = mapaDependenteNome.get(c.id)
                const extraInfo = nomeDependente ? `(Resp. por ${nomeDependente})` : undefined
                mapClientesUnicos.set(c.id, { 
                    id: c.id, 
                    nome: c.full_name + (extraInfo ? ` ${extraInfo}` : ''), 
                    cpf: c.cpf, 
                    fone: c.fone_movel 
                })
            }
        })
        resultados.clientes = Array.from(mapClientesUnicos.values())

        // --- 2. BUSCAR VENDAS ---
        const promisesVendas = []
        
        // CORREÇÃO: Cast as any na query de vendas
        let queryVendasA = (supabaseAdmin
            .from('vendas') as any)
            .select('id, created_at, valor_final, status, customers!inner(full_name)')
            .eq('store_id', storeId)
            .limit(5)
            .order('created_at', { ascending: false })

        if (isNumeric) {
            queryVendasA = queryVendasA.eq('id', cleanTerm)
        } else {
            queryVendasA = queryVendasA.ilike('customers.full_name', `%${cleanTerm}%`)
        }
        promisesVendas.push(queryVendasA)

        if (responsavelIds.length > 0) {
            promisesVendas.push(
                (supabaseAdmin.from('vendas') as any)
                    .select('id, created_at, valor_final, status, customers(full_name)')
                    .eq('store_id', storeId)
                    .in('customer_id', responsavelIds)
                    .limit(5)
                    .order('created_at', { ascending: false })
            )
        }

        const resultadosVendas = await Promise.all(promisesVendas as any)
        const todasVendas = resultadosVendas.flatMap((r: any) => r.data || [])
        const mapVendasUnicas = new Map()
        todasVendas.forEach((v: any) => {
            if (!mapVendasUnicas.has(v.id)) {
                mapVendasUnicas.set(v.id, { 
                    id: v.id, 
                    data: v.created_at, 
                    valor: v.valor_final, 
                    status: v.status, 
                    cliente: v.customers?.full_name || 'N/A' 
                })
            }
        })
        resultados.vendas = Array.from(mapVendasUnicas.values())

        // --- 3. BUSCAR OS ---
        const promisesOS = []
        if (isNumeric) {
            promisesOS.push(
                (supabaseAdmin.from('service_orders') as any)
                    .select('id, created_at, protocolo_fisico, venda_id, customers(full_name)')
                    .eq('store_id', storeId)
                    .or(`id.eq.${cleanTerm},protocolo_fisico.eq.${cleanTerm}`)
                    .limit(5)
            )
        } else {
            promisesOS.push(
                (supabaseAdmin.from('service_orders') as any)
                    .select('id, created_at, protocolo_fisico, venda_id, customers(full_name)')
                    .eq('store_id', storeId)
                    .ilike('protocolo_fisico', `%${cleanTerm}%`)
                    .limit(5)
            )
            promisesOS.push(
                (supabaseAdmin.from('service_orders') as any)
                    .select('id, created_at, protocolo_fisico, venda_id, customers!inner(full_name)')
                    .eq('store_id', storeId)
                    .ilike('customers.full_name', `%${cleanTerm}%`)
                    .limit(5)
            )
            if (dependenteIds.length > 0) {
                promisesOS.push(
                    (supabaseAdmin.from('service_orders') as any)
                        .select('id, created_at, protocolo_fisico, venda_id, customers(full_name)')
                        .eq('store_id', storeId)
                        .in('dependente_id', dependenteIds)
                        .limit(5)
                )
            }
        }

        const resultadosOS = await Promise.all(promisesOS as any)
        const todasOS = resultadosOS.flatMap((r: any) => r.data || [])
        const mapOSUnicas = new Map()
        todasOS.forEach((o: any) => {
            if (!mapOSUnicas.has(o.id)) {
                mapOSUnicas.set(o.id, { 
                    id: o.id, 
                    venda_id: o.venda_id, 
                    protocolo: o.protocolo_fisico, 
                    data: o.created_at, 
                    cliente: o.customers?.full_name || 'N/A', 
                    status: 'Aberta' 
                })
            }
        })
        resultados.os = Array
            .from(mapOSUnicas.values())
            .sort((a: any, b: any) => new Date(b.data).getTime() - new Date(a.data).getTime())
            .slice(0, 5)

        // --- 4. BUSCAR PRODUTOS ---
        // CORREÇÃO: Cast as any na query de produtos
        let queryProd = (supabaseAdmin
            .from('products') as any)
            .select('id, nome, preco_venda, estoque_atual, codigo_barras, tipo_produto')
            .eq('store_id', storeId)
            .limit(10)

        if (isNumeric) {
            queryProd = queryProd.or(`codigo_barras.eq.${cleanTerm},referencia.eq.${cleanTerm}`)
        } else {
            queryProd = queryProd.ilike('nome', `%${cleanTerm}%`)
        }

        const { data: produtosEncontrados } = await queryProd

        if (produtosEncontrados) {
            resultados.produtos = (produtosEncontrados as any[]).map((p: any) => ({
                id: p.id,
                tipo: p.tipo_produto === 'Armacao' ? 'Armação' : 
                      p.tipo_produto === 'Lente' ? 'Lente' : 
                      p.tipo_produto === 'Tratamento' ? 'Tratamento' : 'Geral',
                nome: p.nome,
                preco: p.preco_venda,
                estoque: p.estoque_atual,
                codigo: p.codigo_barras
            }))
        }

        return resultados

    } catch (error) {
        console.error("Erro na busca universal:", error)
        return resultados
    }
}

export type Aniversariante = {
    id: number
    nome: string
    fone: string | null
    dia: string
}

export async function getAniversariantes(storeId: number): Promise<Aniversariante[]> {
    const supabase = createAdminClient()
    
    const hoje = new Date()
    const targetMonth = hoje.getMonth() + 1
    const targetDay = hoje.getDate()

    try {
        // CORREÇÃO: Cast as any para evitar erro caso birth_date seja considerado opcional/null
        const { data, error } = await (supabase
            .from('customers') as any)
            .select('id, full_name, fone_movel, birth_date')
            .eq('store_id', storeId)
            .not('birth_date', 'is', null)
            .limit(5000)

        if (error || !data) return []

        const aniversariantesHoje = data.filter((c: any) => {
            if (!c.birth_date) return false
            const [ano, mes, dia] = c.birth_date.split('-').map(Number)
            return mes === targetMonth && dia === targetDay
        })

        const diaStr = String(targetDay).padStart(2, '0')
        const mesStr = String(targetMonth).padStart(2, '0')

        return aniversariantesHoje.map((c: any) => ({
            id: c.id,
            nome: c.full_name,
            fone: c.fone_movel,
            dia: `${diaStr}/${mesStr}`
        }))

    } catch {
        return []
    }
}

// ==============================================================================
// 02. ACTION: BUSCA PARCELAS PENDENTES QUE VEM HOJE OU AMANHÃ
// ==============================================================================

// ... imports anteriores

export type VencimentoProximo = {
    id: number
    customer_name: string
    fone_movel: string | null
    valor_parcela: number
    data_vencimento: string
    numero_parcela: number
}

export async function getVencimentosProximos(storeId: number): Promise<VencimentoProximo[]> {
    const supabaseAdmin = createAdminClient()
    const hoje = new Date()
    const amanha = new Date(hoje)
    amanha.setDate(hoje.getDate() + 1)

    // Formata YYYY-MM-DD
    const inicio = hoje.toISOString().split('T')[0]
    const fim = amanha.toISOString().split('T')[0]

    try {
        const { data, error } = await (supabaseAdmin.from('financiamento_parcelas') as any)
            .select(`
                id, valor_parcela, data_vencimento, numero_parcela,
                customers ( full_name, fone_movel )
            `)
            .eq('store_id', storeId)
            .eq('status', 'Pendente')
            .gte('data_vencimento', inicio)
            .lte('data_vencimento', fim)
            .order('data_vencimento', { ascending: true })

        if (error) throw error

        return (data || []).map((item: any) => ({
            id: item.id,
            customer_name: item.customers?.full_name || 'Desconhecido',
            fone_movel: item.customers?.fone_movel,
            valor_parcela: item.valor_parcela,
            data_vencimento: item.data_vencimento,
            numero_parcela: item.numero_parcela
        }))
    } catch (e) {
        console.error("Erro ao buscar vencimentos:", e)
        return []
    }
}

==================================================
ARQUIVO: .\src\lib\actions\customer.actions.ts
==================================================
// Caminho: src/lib/actions/customer.actions.ts
'use server'

import { createClient } from '@/lib/supabase/server'
import { Database } from '@/lib/database.types'
import { revalidatePath } from 'next/cache'
import { z } from 'zod'

// Importamos os helpers administrativos para bypassar o RLS (leitura e escrita)
import { getProfileByAdmin, createAdminClient } from '@/lib/supabase/admin'

type Customer = Database['public']['Tables']['customers']['Row']

// --- Funções Helper do CPF ---
function validaCPF(cpf: string | null | undefined): boolean {
  if (!cpf) return false
  const cpfLimpo = cpf.replace(/\D/g, '')
  if (cpfLimpo.length !== 11 || /^(\d)\1+$/.test(cpfLimpo)) return false

  let soma = 0,
    resto
  for (let i = 1; i <= 9; i++)
    soma += parseInt(cpfLimpo.substring(i - 1, i)) * (11 - i)
  
  resto = (soma * 10) % 11
  if (resto === 10 || resto === 11) resto = 0
  if (resto !== parseInt(cpfLimpo.substring(9, 10))) return false

  soma = 0
  for (let i = 1; i <= 10; i++)
    soma += parseInt(cpfLimpo.substring(i - 1, i)) * (12 - i)
  resto = (soma * 10) % 11
  if (resto === 10 || resto === 11) resto = 0
  if (resto !== parseInt(cpfLimpo.substring(10, 11))) return false

  return true
}

// --- Esquema de Validação ---
const CustomerSchema = z.object({
  id: z.coerce.number().optional(),
  // CORREÇÃO ANTERIOR MANTIDA: Removido required_error
  store_id: z.coerce.number(),
  full_name: z.string().min(3, { message: 'Nome completo é obrigatório.' }),
  rg: z.string().optional().nullable(),
  cpf: z.string().optional().nullable(),
  birth_date: z.string().nullable().optional(),
  naturalidade: z.string().optional().nullable(),
  estado_civil: z.string().optional().nullable(),
  pai: z.string().optional().nullable(),
  mae: z.string().optional().nullable(),
  conjuge_nome: z.string().optional().nullable(),
  conjuge_nascimento: z.string().nullable().optional(),
  conjuge_naturalidade: z.string().optional().nullable(),
  conjuge_trabalho: z.string().optional().nullable(),
  conjuge_fone: z.string().optional().nullable(),
  rua: z.string().optional().nullable(),
  numero: z.string().optional().nullable(),
  bairro: z.string().optional().nullable(),
  complemento: z.string().optional().nullable(),
  cidade: z.string().optional().nullable(),
  uf: z.string().optional().nullable(),
  cep: z.string().optional().nullable(),
  phone: z.string().optional().nullable(),
  fone_movel: z.string().optional().nullable(),
  email: z.string().email({ message: 'E-mail inválido.' }).optional().or(z.literal('')).nullable(),
  obs_residencial: z.string().optional().nullable(),
  comercial_trabalho: z.string().optional().nullable(),
  comercial_cargo: z.string().optional().nullable(),
  comercial_endereco: z.string().optional().nullable(),
  comercial_fone: z.string().optional().nullable(),
  comercial_renda: z.coerce.number().optional().nullable(), 
  obs_comercial: z.string().optional().nullable(),
  ref_comercio_1: z.string().optional().nullable(),
  ref_comercio_2: z.string().optional().nullable(),
  ref_pessoal_1: z.string().optional().nullable(),
  ref_pessoal_2: z.string().optional().nullable(),
  obs_debito: z.string().optional().nullable(),
  faixa_etaria: z.string().optional().nullable(),
})

export type CustomerActionResult = {
  success: boolean
  message: string
  data?: Customer
  errors?: Record<string, string[]>
}

//================================================================
// 1. ACTION: SALVAR CLIENTE (NOVO E EDIÇÃO)
//================================================================
export async function saveCustomerDetails(
  prevState: CustomerActionResult,
  formData: FormData
): Promise<CustomerActionResult> {
  const supabase = createClient()
  const customerId = formData.get('id')
  
  // 1. Obter Usuário Logado
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return { success: false, message: 'Usuário não autenticado.' }
  
  // 2. Obter Perfil (CORREÇÃO AQUI: Cast 'as any' para garantir acesso ao tenant_id)
  const profile = await getProfileByAdmin(user.id) as any

  if (!profile?.tenant_id || !profile?.store_id) {
    return { success: false, message: 'Perfil do usuário incompleto (sem loja/tenant).' }
  }
  
  const { tenant_id, store_id } = profile

  // 3. Pré-processar CPF
  const emptyToNull = (value: FormDataEntryValue | null) => value === '' ? null : value
  const cpfFromForm = emptyToNull(formData.get('cpf')) as string | null
  const unmaskedCpf = cpfFromForm ? cpfFromForm.replace(/\D/g, '') : null
  const cpfToSave = unmaskedCpf 
  
  // 4. Validar Campos
  const validatedFields = CustomerSchema.safeParse({
    id: customerId,
    store_id: store_id,
    full_name: formData.get('full_name'),
    rg: emptyToNull(formData.get('rg')),
    cpf: cpfToSave,
    birth_date: emptyToNull(formData.get('birth_date')),
    naturalidade: emptyToNull(formData.get('naturalidade')),
    estado_civil: emptyToNull(formData.get('estado_civil')),
    pai: emptyToNull(formData.get('pai')),
    mae: emptyToNull(formData.get('mae')),
    conjuge_nome: emptyToNull(formData.get('conjuge_nome')),
    conjuge_nascimento: emptyToNull(formData.get('conjuge_nascimento')),
    conjuge_naturalidade: emptyToNull(formData.get('conjuge_naturalidade')),
    conjuge_trabalho: emptyToNull(formData.get('conjuge_trabalho')),
    conjuge_fone: emptyToNull(formData.get('conjuge_fone')),
    rua: emptyToNull(formData.get('rua')),
    numero: emptyToNull(formData.get('numero')),
    bairro: emptyToNull(formData.get('bairro')),
    complemento: emptyToNull(formData.get('complemento')),
    cidade: emptyToNull(formData.get('cidade')),
    uf: emptyToNull(formData.get('uf')),
    cep: emptyToNull(formData.get('cep')),
    phone: emptyToNull(formData.get('phone')),
    fone_movel: formData.get('fone_movel'),
    email: emptyToNull(formData.get('email')),
    obs_residencial: emptyToNull(formData.get('obs_residencial')),
    comercial_trabalho: emptyToNull(formData.get('comercial_trabalho')),
    comercial_cargo: emptyToNull(formData.get('comercial_cargo')),
    comercial_endereco: emptyToNull(formData.get('comercial_endereco')),
    comercial_fone: emptyToNull(formData.get('comercial_fone')),
    comercial_renda: emptyToNull(formData.get('comercial_renda')),
    obs_comercial: emptyToNull(formData.get('obs_comercial')),
    ref_comercio_1: emptyToNull(formData.get('ref_comercio_1')),
    ref_comercio_2: emptyToNull(formData.get('ref_comercio_2')),
    ref_pessoal_1: emptyToNull(formData.get('ref_pessoal_1')),
    ref_pessoal_2: emptyToNull(formData.get('ref_pessoal_2')),
    obs_debito: emptyToNull(formData.get('obs_debito')),
    faixa_etaria: emptyToNull(formData.get('faixa_etaria')),
  })

  if (!validatedFields.success) {
    return {
      success: false,
      message: 'Erro de validação. Verifique os campos.',
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  const { id: _, store_id: __, ...customerData } = validatedFields.data
  
  // CORREÇÃO MANTIDA: any aqui para aceitar campos novos
  const dataToSave: any = {
      ...customerData,
      store_id: store_id,
      tenant_id: tenant_id, 
  }

  const supabaseAdmin = createAdminClient();

  // --- TRAVA DE SEGURANÇA ---
  let queryDuplicidade = (supabaseAdmin
      .from('customers') as any)
      .select('id')
      .eq('store_id', store_id)
      .ilike('full_name', dataToSave.full_name)
      
  if (customerId) {
      queryDuplicidade = queryDuplicidade.neq('id', customerId)
  }

  const { data: duplicados } = await queryDuplicidade.limit(1)

  if (duplicados && duplicados.length > 0) {
      return { 
          success: false, 
          message: `Atenção: Já existe um cliente cadastrado com o nome "${dataToSave.full_name}".` 
      }
  }

  try {
    let error;
    let savedData: Customer | null = null;
    
    if (customerId) {
      // CORREÇÃO MANTIDA: Cast 'as any'
      const { data, error: updateError } = await (supabaseAdmin.from('customers') as any)
        .update(dataToSave)
        .eq('id', customerId)
        .select()
        .single();
      error = updateError;
      savedData = data;
    } else {
      // CORREÇÃO MANTIDA: Cast 'as any'
      const { data, error: insertError } = await (supabaseAdmin.from('customers') as any)
        .insert(dataToSave)
        .select()
        .single();
      error = insertError;
      savedData = data;
    }

    if (error) {
      if (error.message.includes('customers_cpf_key')) {
        return { success: false, message: 'Erro: Já existe um cliente com este CPF.' }
      }
      throw new Error(error.message)
    }

    revalidatePath(`/dashboard/loja/${store_id}/clientes`);

    return { success: true, message: 'Cliente salvo com sucesso!', data: savedData! }

  } catch (error: any) {
    return { success: false, message: `Erro no banco de dados: ${error.message}` }
  }
}

//================================================================
// 2. ACTION: DELETAR CLIENTE
//================================================================

export async function deleteCustomer(
    customerId: number,
    storeId: number,
): Promise<CustomerActionResult> {
    const supabaseAdmin = createAdminClient();

    try {
        const { error: deleteError } = await (supabaseAdmin.from('customers') as any)
            .delete()
            .eq('id', customerId)

        if (deleteError) throw new Error(deleteError.message)

        revalidatePath(`/dashboard/loja/${storeId}/clientes`)
        return { success: true, message: 'Cliente deletado com sucesso.' }
    } catch (error: any) {
        return { success: false, message: `Erro ao deletar: ${error.message}` }
    }
}

// ================================================================
// 3. ACTION: CADASTRO RÁPIDO (BALCÃO)
// ================================================================
const QuickCustomerSchema = z.object({
  store_id: z.coerce.number(),
  full_name: z.string().min(3, "Nome muito curto."),
  fone_movel: z.string().min(8, "Telefone inválido."),
})

export async function createQuickCustomer(formData: FormData): Promise<CustomerActionResult> {
    const supabaseAdmin = createAdminClient()
    const { data: { user } } = await createClient().auth.getUser()
    
    if (!user) return { success: false, message: 'Sem permissão.' }
    
    // CORREÇÃO AQUI: Cast 'as any' no profile também
    const profile = await getProfileByAdmin(user.id) as any

    const rawData = {
        store_id: formData.get('store_id'),
        full_name: formData.get('full_name'),
        fone_movel: formData.get('fone_movel')
    }

    const validated = QuickCustomerSchema.safeParse(rawData)
    
    if (!validated.success) {
        return { success: false, message: 'Dados inválidos.', errors: validated.error.flatten().fieldErrors }
    }

    const { store_id, full_name, fone_movel } = validated.data

    try {
        // CORREÇÃO MANTIDA: Cast 'as any'
        const { data: existe } = await (supabaseAdmin.from('customers') as any)
            .select('id')
            .eq('store_id', store_id)
            .ilike('full_name', full_name.trim())
            .maybeSingle()
        
        if (existe) {
            return { success: false, message: 'Já existe um cliente com este nome exato.' }
        }

        // CORREÇÃO MANTIDA: Cast 'as any' no insert
        const { data: newCustomer, error } = await (supabaseAdmin.from('customers') as any).insert({
            tenant_id: profile?.tenant_id,
            store_id,
            full_name: full_name.trim(),
            fone_movel: fone_movel.replace(/\D/g, ''),
            created_at: new Date().toISOString()
        }).select().single()

        if (error) throw error

        revalidatePath(`/dashboard/loja/${store_id}/clientes`)
        return { success: true, message: 'Cliente cadastrado!', data: newCustomer }

    } catch (e: any) {
        return { success: false, message: e.message }
    }
}

==================================================
ARQUIVO: .\src\lib\actions\dashboard.actions.ts
==================================================
// Caminho: src/lib/actions/dashboard.actions.ts
'use server'

import { createAdminClient } from '@/lib/supabase/admin'
import { createClient } from '@/lib/supabase/server'
import { getAniversariantes } from '@/lib/actions/consultas.actions'

export type StoreKPIs = {
    faturamentoDia: number
    faturamentoMes: number
    ticketMedio: number
    qtdVendasDia: number
    aniversariantes: { id: number; nome: string; fone: string | null; dia: string }[]
    estoqueCritico: number
}

export type NetworkKPIs = {
    totalRedeDia: number
    totalRedeMes: number
    lojas: {
        id: number
        nome: string
        vendasDia: number
    }[]
}

const getDates = () => {
    const now = new Date()
    const inicioDia = new Date(now.setHours(0,0,0,0)).toISOString()
    const fimDia = new Date(now.setHours(23,59,59,999)).toISOString()
    const inicioMes = new Date(now.getFullYear(), now.getMonth(), 1).toISOString()
    return { inicioDia, fimDia, inicioMes }
}

// 1. KPI DO GERENTE (Loja Específica)
export async function getManagerKPIs(storeId: number): Promise<StoreKPIs> {
    const supabase = createAdminClient()
    const { inicioDia, fimDia, inicioMes } = getDates()

    console.log('[KPI] Calculando KPIs para loja', storeId)

    // A. Vendas do Dia
    // CORREÇÃO: Cast as any na tabela vendas
    const { data: vendasDia } = await (supabase
        .from('vendas') as any)
        .select('valor_final')
        .eq('store_id', storeId)
        .eq('status', 'Fechada')
        .gte('created_at', inicioDia)
        .lte('created_at', fimDia)

    const faturamentoDia = vendasDia?.reduce((acc: number, v: any) => acc + v.valor_final, 0) || 0
    const qtdVendasDia = vendasDia?.length || 0
    
    // B. Vendas do Mês
    // CORREÇÃO: Cast as any na tabela vendas
    const { data: vendasMes } = await (supabase
        .from('vendas') as any)
        .select('valor_final')
        .eq('store_id', storeId)
        .eq('status', 'Fechada')
        .gte('created_at', inicioMes)

    const faturamentoMes = vendasMes?.reduce((acc: number, v: any) => acc + v.valor_final, 0) || 0
    const qtdVendasMes = vendasMes?.length || 0
    const ticketMedio = qtdVendasMes > 0 ? faturamentoMes / qtdVendasMes : 0

    // C. Estoque Crítico
    // CORREÇÃO: Cast as any na tabela products
    const { count: estoqueCritico } = await (supabase
        .from('products') as any)
        .select('*', { count: 'exact', head: true })
        .eq('store_id', storeId)
        .eq('gerencia_estoque', true)
        .lt('estoque_atual', 5)

    // D. Aniversariantes
    const aniversariantes = await getAniversariantes(storeId)
    console.log('[KPI] Aniversariantes retornados para loja', storeId, ':', aniversariantes.length)

    return {
        faturamentoDia,
        faturamentoMes,
        ticketMedio,
        qtdVendasDia,
        aniversariantes,
        estoqueCritico: estoqueCritico || 0,
    }
}

export async function getAdminKPIs(): Promise<NetworkKPIs> {
    const supabase = createAdminClient()
    const { inicioDia, inicioMes } = getDates()

    // CORREÇÃO: Cast as any na tabela stores
    const { data: lojas } = await (supabase.from('stores') as any).select('id, name')
    if (!lojas) return { totalRedeDia: 0, totalRedeMes: 0, lojas: [] }

    let totalRedeDia = 0
    let totalRedeMes = 0
    const performanceLojas: NetworkKPIs['lojas'] = []

    for (const loja of lojas) {
        // Como 'lojas' veio de um any, garantimos que loja.id existe
        const kpis = await getManagerKPIs(loja.id)
        totalRedeDia += kpis.faturamentoDia
        totalRedeMes += kpis.faturamentoMes
        performanceLojas.push({
            id: loja.id,
            nome: loja.name,
            vendasDia: kpis.faturamentoDia
        })
    }

    return {
        totalRedeDia,
        totalRedeMes,
        lojas: performanceLojas.sort((a, b) => b.vendasDia - a.vendasDia)
    }
}

==================================================
ARQUIVO: .\src\lib\actions\dependents.actions.ts
==================================================
// ARQUIVO: src/lib/actions/dependents.actions.ts
'use server'

import { z } from 'zod'
import { createAdminClient, getProfileByAdmin } from '@/lib/supabase/admin'
import { createClient } from '@/lib/supabase/server'
import { Database } from '@/lib/database.types'

type Dependente = Database['public']['Tables']['dependentes']['Row']

const DependenteSchema = z.object({
  id: z.coerce.number().optional(), // Aceita ID para edição
  store_id: z.coerce.number(),
  customer_id: z.coerce.number(),
  nome_completo: z.string().min(2, 'Nome obrigatório'),
  parentesco: z.string().min(2, 'Parentesco obrigatório'),
  data_nascimento: z.string().optional().nullable(),
})

export type SaveDependenteResult = {
  success: boolean
  message: string
  data?: Dependente
  errors?: Record<string, string[]>
}

// --- SALVAR (CRIAR OU EDITAR) ---
export async function saveDependente(
  prevState: SaveDependenteResult,
  formData: FormData
): Promise<SaveDependenteResult> {
  const supabase = createClient()
  
  // 1. Autenticação
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return { success: false, message: 'Usuário não autenticado.' }

  // 2. Contexto de Segurança (Tenant)
  const profile = await getProfileByAdmin(user.id)
  
  // Cast as any no profile para garantir leitura do tenant_id
  if (!(profile as any)?.tenant_id) {
    return { success: false, message: 'Erro de permissão: Usuário sem vínculo com Tenant.' }
  }
  const tenantId = (profile as any).tenant_id

  // 3. Validação
  const rawData = {
    id: formData.get('id'),
    store_id: formData.get('store_id'),
    customer_id: formData.get('customer_id'),
    nome_completo: formData.get('nome_completo'),
    parentesco: formData.get('parentesco'),
    data_nascimento: formData.get('data_nascimento') || null,
  }

  const validated = DependenteSchema.safeParse(rawData)

  if (!validated.success) {
    return { 
      success: false, 
      message: 'Erro de validação nos dados.', 
      errors: validated.error.flatten().fieldErrors 
    }
  }

  const { id, ...depData } = validated.data
  const supabaseAdmin = createAdminClient()

  try {
    const payload = {
      tenant_id: tenantId,
      store_id: depData.store_id,
      customer_id: depData.customer_id,
      full_name: depData.nome_completo,
      birth_date: depData.data_nascimento,
      parentesco: depData.parentesco
    }

    let data: Dependente | null = null
    let error = null

    if (id) {
      // --- MODO EDIÇÃO (UPDATE) ---
      // CORREÇÃO: Cast 'as any' no update
      const res = await (supabaseAdmin.from('dependentes') as any)
        .update(payload)
        .eq('id', id)
        .select()
        .single()
      data = res.data
      error = res.error
    } else {
      // --- MODO CRIAÇÃO (INSERT) ---
      // CORREÇÃO: Cast 'as any' no insert
      const res = await (supabaseAdmin.from('dependentes') as any)
        .insert(payload)
        .select()
        .single()
      data = res.data
      error = res.error
    }

    if (error) throw error

    return { success: true, message: id ? 'Dependente atualizado!' : 'Dependente adicionado!', data: data! }
  } catch (error: any) {
    console.error("Erro save dependente:", error)
    return { success: false, message: `Erro ao salvar: ${error.message}` }
  }
}

// --- BUSCAR LISTA ---
export async function getDependentes(customerId: number) {
  const supabaseAdmin = createAdminClient()
  
  // CORREÇÃO: Cast 'as any' no select
  const { data, error } = await (supabaseAdmin.from('dependentes') as any)
    .select('*')
    .eq('customer_id', customerId)
    .order('created_at', { ascending: false })

  if (error) return []
  return data as Dependente[]
}

// --- EXCLUIR ---
export async function deleteDependente(dependenteId: number) {
  const supabaseAdmin = createAdminClient()
  
  // CORREÇÃO: Cast 'as any' no delete
  const { error } = await (supabaseAdmin.from('dependentes') as any)
    .delete()
    .eq('id', dependenteId)

  if (error) return { success: false, message: error.message }
  return { success: true, message: 'Dependente removido.' }
}

==================================================
ARQUIVO: .\src\lib\actions\employee.actions.ts
==================================================
// Caminho: src/lib/actions/employee.actions.ts
'use server'

import { Database } from '@/lib/database.types'
import { revalidatePath } from 'next/cache'
import { z } from 'zod'
import { createAdminClient, getProfileByAdmin } from '@/lib/supabase/admin'
import { createClient } from '@/lib/supabase/server'

type Employee = Database['public']['Tables']['employees']['Row']

// --- Schema de Validação ---
const EmployeeSchema = z.object({
  id: z.coerce.number().optional(),
  store_id: z.coerce.number(),
  full_name: z.string().min(2, 'Nome deve ter pelo menos 2 letras.'),
  pin: z.string().min(4, 'O PIN deve ter pelo menos 4 números.'),
  role: z.enum(['vendedor', 'gerente', 'tecnico']).optional().default('vendedor'),
  is_active: z.boolean().optional(),
  comm_rate_guaranteed: z.coerce.number().min(0).optional(),
  comm_rate_store_credit: z.coerce.number().min(0).optional(),
  comm_rate_store_total: z.coerce.number().min(0).optional(),
  comm_rate_received: z.coerce.number().min(0).optional(),
  comm_rate_profit: z.coerce.number().min(0).optional(),
})

export type EmployeeActionResult = {
  success: boolean
  message: string
  errors?: Record<string, string[]>
}

// --- Helper de Contexto Seguro ---
async function getManagerContext() {
  const supabase = createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Usuário não autenticado.')
  
  const profile = await getProfileByAdmin(user.id)
  
  // Apenas Managers ou Admins podem gerenciar equipe
  // Cast 'as any' para garantir acesso às propriedades
  const p = profile as any;
  if (!p || (p.role !== 'manager' && p.role !== 'admin')) {
      throw new Error('Permissão negada. Apenas gerentes podem acessar esta área.')
  }
  
  return { profile: p, supabaseAdmin: createAdminClient() }
}

// 1. SALVAR (CRIAR / EDITAR)
export async function saveEmployee(
  prevState: EmployeeActionResult, 
  formData: FormData
): Promise<EmployeeActionResult> {
  try {
    const { profile, supabaseAdmin } = await getManagerContext()
    
    const rawFormData = {
      id: formData.get('id') ? parseInt(formData.get('id') as string) : undefined,
      store_id: profile.store_id,
      full_name: formData.get('full_name'),
      pin: formData.get('pin'),
      role: formData.get('role'),
      is_active: true,
      comm_rate_guaranteed: formData.get('comm_rate_guaranteed'),
      comm_rate_store_credit: formData.get('comm_rate_store_credit'),
      comm_rate_store_total: formData.get('comm_rate_store_total'),
      comm_rate_received: formData.get('comm_rate_received'),
      comm_rate_profit: formData.get('comm_rate_profit'),
    }

    const validated = EmployeeSchema.safeParse(rawFormData)

    if (!validated.success) {
      return { 
        success: false, 
        message: 'Dados inválidos.', 
        errors: validated.error.flatten().fieldErrors 
      }
    }

    const { id, ...data } = validated.data
    
    // --- VERIFICAÇÃO DE PIN DUPLICADO ---
    // Cast 'as any' na chamada do banco
    const { data: existingRaw } = await (supabaseAdmin.from('employees') as any)
        .select('id, full_name')
        .eq('store_id', profile.store_id)
        .eq('pin', data.pin)
        .maybeSingle()

    const existingEmployee = existingRaw as any;

    // Se achou alguém E (estamos criando novo OU editando e o ID é diferente do encontrado)
    if (existingEmployee && (!id || existingEmployee.id !== id)) {
        return { 
            success: false, 
            message: `Erro: O PIN ${data.pin} já pertence a ${existingEmployee.full_name}.` 
        }
    }
    // -------------------------------------

    const payload = { ...data, tenant_id: profile.tenant_id }

if (id) {
      // ATUALIZAÇÃO: O payload já contém os novos campos graças ao spread '...data'
      const { error } = await (supabaseAdmin.from('employees') as any)
        .update(payload) // Payload completo com comissões
        .eq('id', id)
        .eq('store_id', profile.store_id)
      
      if (error) throw error
    } else {
      const { error } = await (supabaseAdmin.from('employees') as any)
        .insert(payload)
      
      if (error) throw error
    }

    revalidatePath(`/dashboard/loja/${profile.store_id}/config`)
    return { success: true, message: 'Funcionário salvo com sucesso!' }

  } catch (error: any) {
    return { success: false, message: error.message }
  }
}

// 2. LISTAR FUNCIONÁRIOS
// 2. LISTAR FUNCIONÁRIOS (ATUALIZADO COM COLUNAS EXPLÍCITAS)
export async function getEmployees(storeId: number): Promise<Employee[]> {
  const supabaseAdmin = createAdminClient()
  
  // Cast 'as any' na chamada
  const { data, error } = await (supabaseAdmin.from('employees') as any)
    .select(`
      id, 
      store_id, 
      full_name, 
      pin, 
      role, 
      is_active, 
      created_at,
      comm_rate_guaranteed,
      comm_rate_store_credit,
      comm_rate_store_total,
      comm_rate_received,
      comm_rate_profit,
      comm_tiers_json
    `)
    .eq('store_id', storeId)
    .order('full_name')

  if (error) {
    console.error('Erro ao buscar funcionários:', error)
    return []
  }
  return data as Employee[]
}

// 3. ALTERAR STATUS (SOFT DELETE)
export async function toggleEmployeeStatus(
    employeeId: number, 
    currentStatus: boolean,
    storeId: number
): Promise<EmployeeActionResult> {
    try {
        const supabaseAdmin = createAdminClient()
        
        // Cast 'as any' na chamada
        const { error } = await (supabaseAdmin.from('employees') as any)
            .update({ is_active: !currentStatus })
            .eq('id', employeeId)
            .eq('store_id', storeId)

        if (error) throw error

        revalidatePath(`/dashboard/loja/${storeId}/config`)
        return { success: true, message: `Funcionário ${!currentStatus ? 'ativado' : 'inativado'}.` }
    } catch (error: any) {
        return { success: false, message: error.message }
    }
}

==================================================
ARQUIVO: .\src\lib\actions\gaveta.actions.ts
==================================================
'use server'

import { createClient } from '@/lib/supabase/server'

export async function getGavetaItems(storeId: number) {
  const supabase = createClient()

  try {
    const { data, error } = await supabase
      .from('service_orders')
      .select(`
        *,
        customers (
          id,
          full_name,
          fone_movel, 
          mobile_phone 
        ),
        vendas (
          id,
          valor_restante
        ),
        dependente:dependentes (
          id,
          nome_completo
        )
      `)
      .eq('store_id', storeId)
      .not('dt_montado_em', 'is', null) // Já está pronto
      .is('dt_entregue_em', null)       // Ainda não foi entregue
      .order('dt_montado_em', { ascending: true }) // Os mais antigos primeiro

    if (error) {
      console.error('Erro ao buscar gaveta:', error)
      return { success: false, error: error.message }
    }

    return { success: true, data }
  } catch (err: any) {
    return { success: false, error: err.message }
  }
}

==================================================
ARQUIVO: .\src\lib\actions\import.actions.ts
==================================================
// ARQUIVO: src/lib/actions/import.actions.ts
'use server'

import { createClient } from '@/lib/supabase/server'
import { createAdminClient, getProfileByAdmin } from '@/lib/supabase/admin'
import { XMLParser } from 'fast-xml-parser'
import { revalidatePath } from 'next/cache'

// Tipos para o Preview
export type XmlPreviewItem = {
    codigo_fornecedor: string
    codigo_barras: string // cEAN
    descricao: string
    ncm: string
    cest: string
    cfop: string
    unidade: string
    quantidade: number
    valor_unitario: number // Custo Calculado (Com impostos)
    valor_total: number
    // Status para a UI
    status_sistema: 'Novo' | 'Encontrado' | 'Vinculado'
    id_sistema?: number // Se já existir
    estoque_atual?: number
}

export type XmlPreviewData = {
    access_key: string // Chave de Acesso (44 dígitos)
    nfe_numero: string
    nfe_serie: string
    data_emissao: string
    fornecedor: {
        cnpj: string
        nome: string // xNome
        fantasia: string // xFant
        ie: string // IE
        cidade: string
        uf: string
        status_sistema: 'Novo' | 'Cadastrado'
        id_sistema?: number
    }
    itens: XmlPreviewItem[]
}

// Helper para limpar string de chave (remove 'NFe' se tiver)
const cleanKey = (key: string) => key?.replace('NFe', '') || ''

// Helper seguro para float
const parseFloatSafe = (val: any) => {
    if (!val) return 0
    return parseFloat(val)
}

// ============================================================================
// 1. LER XML E GERAR PREVIEW
// ============================================================================
export async function parseNfeAndPreview(formData: FormData): Promise<{ success: boolean, data?: XmlPreviewData, message?: string }> {
    const supabaseAdmin = createAdminClient()
    const { data: { user } } = await createClient().auth.getUser()
    if (!user) return { success: false, message: 'Login necessário.' }
    
    // Cast as any para garantir acesso às props do perfil
    const profile = await getProfileByAdmin(user.id) as any
    if (!profile) return { success: false, message: 'Perfil não encontrado.' }

    const file = formData.get('xml_file') as File
    if (!file) return { success: false, message: 'Arquivo não enviado.' }

    try {
        const text = await file.text()
        const parser = new XMLParser({ ignoreAttributes: false, attributeNamePrefix: "@_" })
        const xmlObj = parser.parse(text)

        // Navegar na estrutura NFe
        const nfeProc = xmlObj.nfeProc || xmlObj.NFe
        if (!nfeProc || !nfeProc.NFe) throw new Error("XML inválido ou não é uma NFe.")
        
        const infNFe = nfeProc.NFe.infNFe
        
        // 1. TRAVA DE SEGURANÇA: Verificar Chave de Acesso
        const rawKey = infNFe["@_Id"] 
        if (!rawKey) throw new Error("Chave de acesso não encontrada no XML.")
        
        const accessKey = cleanKey(rawKey)
        
        // CORREÇÃO: Cast 'as any' para tabela imported_invoices
        const { data: invoiceExists } = await (supabaseAdmin.from('imported_invoices') as any)
            .select('id, imported_at')
            .eq('store_id', profile.store_id)
            .eq('access_key', accessKey)
            .maybeSingle()

        if (invoiceExists) {
            const dataImp = new Date(invoiceExists.imported_at).toLocaleDateString('pt-BR')
            return { success: false, message: `ATENÇÃO: Esta nota fiscal já foi importada no dia ${dataImp}.` }
        }

        // 2. Dados Gerais
        const emit = infNFe.emit
        const detList = Array.isArray(infNFe.det) ? infNFe.det : [infNFe.det] 

        // 3. Processar Fornecedor
        const cnpjFornecedor = emit.CNPJ
        const fornecedorPreview = {
            cnpj: cnpjFornecedor,
            nome: emit.xNome,
            fantasia: emit.xFant || emit.xNome,
            ie: emit.IE,
            cidade: emit.enderEmit?.xMun || '',
            uf: emit.enderEmit?.UF || '',
            status_sistema: 'Novo' as 'Novo' | 'Cadastrado',
            id_sistema: undefined as number | undefined
        }

        // Verifica se fornecedor existe no banco
        // CORREÇÃO: Cast 'as any' para tabela suppliers
        const { data: existingSupplier } = await (supabaseAdmin.from('suppliers') as any)
            .select('id')
            .eq('store_id', profile.store_id)
            .eq('cnpj', cnpjFornecedor)
            .maybeSingle()

        if (existingSupplier) {
            fornecedorPreview.status_sistema = 'Cadastrado'
            fornecedorPreview.id_sistema = existingSupplier.id
        }

        // 4. Processar Produtos
        const itensPreview: XmlPreviewItem[] = []
        const eansDoXml = detList.map((d: any) => d.prod.cEAN).filter((c: string) => c && c !== 'SEM GTIN')
        
        // CORREÇÃO: Cast 'as any' para tabela products
        const { data: produtosExistentes } = await (supabaseAdmin.from('products') as any)
            .select('id, codigo_barras, estoque_atual, nome')
            .eq('store_id', profile.store_id)
            .in('codigo_barras', eansDoXml)

        for (const det of detList) {
            const prod = det.prod
            const impostos = det.imposto || {}
            
            // CÁLCULO DO CUSTO EFETIVO (LANDED COST)
            const vProd = parseFloatSafe(prod.vProd)
            const qCom = parseFloatSafe(prod.qCom)
            const vDesc = parseFloatSafe(prod.vDesc)
            const vFrete = parseFloatSafe(prod.vFrete)
            const vSeg = parseFloatSafe(prod.vSeg)
            const vOutro = parseFloatSafe(prod.vOutro)
            
            const vIPI = parseFloatSafe(impostos.IPI?.IPITrib?.vIPI)
            const vST = parseFloatSafe(impostos.ICMS?.ICMS10?.vICMSST) || parseFloatSafe(impostos.ICMS?.ICMS30?.vICMSST) || parseFloatSafe(impostos.ICMS?.ICMS70?.vICMSST) || parseFloatSafe(impostos.ICMS?.ICMS90?.vICMSST) || 0
            
            const custoTotalItem = vProd + vIPI + vST + vFrete + vSeg + vOutro - vDesc
            const custoUnitarioReal = custoTotalItem / qCom

            const match = produtosExistentes?.find((p: any) => p.codigo_barras === prod.cEAN)

            itensPreview.push({
                codigo_fornecedor: prod.cProd,
                codigo_barras: prod.cEAN !== 'SEM GTIN' ? prod.cEAN : '',
                descricao: prod.xProd,
                ncm: String(prod.NCM || ''),
                cest: String(prod.CEST || ''),
                cfop: prod.CFOP,
                unidade: prod.uCom,
                quantidade: qCom,
                valor_unitario: parseFloat(custoUnitarioReal.toFixed(2)),
                valor_total: vProd,
                status_sistema: match ? 'Encontrado' : 'Novo',
                id_sistema: match?.id,
                estoque_atual: match?.estoque_atual
            })
        }

        return {
            success: true,
            data: {
                access_key: accessKey,
                nfe_numero: infNFe.ide.nNF,
                nfe_serie: infNFe.ide.serie,
                data_emissao: infNFe.ide.dhEmi,
                fornecedor: fornecedorPreview,
                itens: itensPreview
            }
        }

    } catch (e: any) {
        console.error("Erro ao ler XML:", e)
        return { success: false, message: "Erro ao processar XML: " + e.message }
    }
}

// ============================================================================
// 2. GRAVAR DADOS (COMMIT)
// ============================================================================
export async function saveImportedData(data: XmlPreviewData, storeId: number) {
    const supabaseAdmin = createAdminClient()
    const { data: { user } } = await createClient().auth.getUser()
    if (!user) return { success: false, message: 'Login necessário.' }
    
    // Cast 'as any' para garantir acesso
    const profile = await getProfileByAdmin(user.id) as any
    if (!profile) return { success: false, message: 'Perfil inválido.' }

    try {
        // 1. Salvar/Atualizar Fornecedor
        let supplierId = data.fornecedor.id_sistema

        if (!supplierId) {
            // CORREÇÃO: Cast 'as any' para insert em suppliers
            const { data: newSup, error } = await (supabaseAdmin.from('suppliers') as any).insert({
                tenant_id: profile.tenant_id,
                store_id: storeId,
                nome_fantasia: data.fornecedor.fantasia,
                razao_social: data.fornecedor.nome,
                cnpj: data.fornecedor.cnpj,
                inscricao_estadual: data.fornecedor.ie,
                cidade: data.fornecedor.cidade,
                uf: data.fornecedor.uf
            }).select().single()
            
            if (error) throw new Error("Erro ao criar fornecedor: " + error.message)
            supplierId = newSup.id
        }

        // 2. Processar Produtos
        for (const item of data.itens) {
            
            const nome = item.descricao.toUpperCase()
            const ncmString = String(item.ncm || '') 
            const ncm = ncmString.replace(/\./g, '')
            
            let tipoDetectado = 'Outro'
            let categoriaDetectada = 'Importado XML'

            // Lógica de Detecção
            if (ncm.startsWith('9003') || ncm.startsWith('9004')) {
                tipoDetectado = 'Armacao'
                categoriaDetectada = 'Armação'
            } else if (ncm.startsWith('9001')) {
                tipoDetectado = 'Lente'
                categoriaDetectada = 'Lente Oftálmica'
            } else {
                if (nome.includes('ARMA') || nome.includes('OCULOS') || nome.includes('SOLAR')) {
                    tipoDetectado = 'Armacao'
                    categoriaDetectada = 'Armação'
                } else if (nome.includes('LENTE')) {
                    tipoDetectado = 'Lente'
                    categoriaDetectada = 'Lente Oftálmica'
                }
            }

            const precoVendaSugerido = item.valor_unitario * 2 

            let productId = item.id_sistema

            if (productId) {
                // PRODUTO JÁ EXISTE: Atualiza estoque via RPC
                // CORREÇÃO: Cast 'as any' para RPC
                const { error: updateError } = await (supabaseAdmin as any).rpc('increment_stock', { 
                    p_product_id: productId, 
                    p_quantity: item.quantidade,
                    p_new_cost: item.valor_unitario
                })
                
                // Fallback se RPC falhar ou não existir
                if (updateError) { 
                    const { data: prodAtual } = await (supabaseAdmin.from('products') as any)
                        .select('estoque_atual')
                        .eq('id', productId)
                        .single()
                        
                    await (supabaseAdmin.from('products') as any).update({
                        estoque_atual: (prodAtual?.estoque_atual || 0) + item.quantidade,
                        preco_custo: item.valor_unitario,
                    }).eq('id', productId)
                }
            } else {
                // PRODUTO NOVO: Cria o registro
                // CORREÇÃO: Cast 'as any' para insert em products
                const { data: newProd, error: insertError } = await (supabaseAdmin.from('products') as any).insert({
                    tenant_id: profile.tenant_id,
                    store_id: storeId,
                    nome: item.descricao,
                    codigo_barras: item.codigo_barras || null,
                    referencia: item.codigo_fornecedor,
                    tipo_produto: tipoDetectado, 
                    categoria: categoriaDetectada,
                    marca: null, 
                    preco_custo: item.valor_unitario,
                    preco_venda: precoVendaSugerido,
                    estoque_atual: item.quantidade,
                    estoque_minimo: 1,
                    gerencia_estoque: true,
                    ncm: ncm,
                    cest: item.cest,
                    cfop: item.cfop,
                    unidade_medida: item.unidade,
                    origem_mercadoria: 0,
                    supplier_id: supplierId,
                    detalhes: {} 
                }).select().single()

                if (insertError) throw new Error(`Erro ao criar produto ${item.descricao}: ${insertError.message}`)
                productId = newProd.id
            }

            // 3. Registrar Movimentação (Log)
            // CORREÇÃO: Cast 'as any' para insert em stock_movements
            await (supabaseAdmin.from('stock_movements') as any).insert({
                tenant_id: profile.tenant_id,
                store_id: storeId,
                product_id: productId,
                tipo: 'Entrada',
                quantidade: item.quantidade,
                motivo: `Importação NFe ${data.nfe_numero}`,
                custo_unitario_momento: item.valor_unitario,
                registrado_por_id: user.id
            })
        }

        // 4. Registrar a Nota
        // CORREÇÃO: Cast 'as any' para insert em imported_invoices
        await (supabaseAdmin.from('imported_invoices') as any).insert({
            tenant_id: profile.tenant_id,
            store_id: storeId,
            access_key: data.access_key,
            nfe_number: data.nfe_numero,
            series: data.nfe_serie,
            supplier_id: supplierId,
            imported_at: new Date().toISOString()
        })

        revalidatePath(`/dashboard/loja/${storeId}/cadastros`)
        return { success: true, message: "Importação concluída com sucesso!" }

    } catch (e: any) {
        if (e.message?.includes('unique_invoice_key_per_store')) {
            return { success: false, message: "Erro: Esta nota fiscal já foi registrada no sistema." }
        }
        console.error("Erro ao salvar importação:", e)
        return { success: false, message: e.message }
    }
}

// ============================================================================
// 3. IMPORTAÇÃO DE LENTES (CSV)
// ============================================================================

export type LenteImportada = {
    nome_completo: string
    marca: string
    linha: string
    material: string
    tipo_lente: string
    preco_venda: number
    preco_custo: number
    detalhes: any
}

export type ImportResult = {
    success: boolean
    message: string
    processed: number
    updated: number
    created: number
    errors: string[]
}

export async function processarImportacaoLentes(
    storeId: number, 
    lentes: LenteImportada[]
): Promise<ImportResult> {
    const supabaseAdmin = createAdminClient()
    
    const { data: { user } } = await createClient().auth.getUser()
    if (!user) return { success: false, message: 'Usuário não logado.', processed: 0, updated: 0, created: 0, errors: [] }
    
    // Cast 'as any' no profile
    const profile = await getProfileByAdmin(user.id) as any
    if (!profile) return { success: false, message: 'Perfil inválido.', processed: 0, updated: 0, created: 0, errors: [] }

    let createdCount = 0
    let updatedCount = 0
    const errors: string[] = []

    try {
        // 1. Buscar produtos existentes (lentes)
        // CORREÇÃO: Cast 'as any' para select em products
        const { data: produtosExistentes } = await (supabaseAdmin.from('products') as any)
            .select('id, nome, preco_venda, preco_custo')
            .eq('store_id', storeId)
            .eq('tipo_produto', 'Lente')

        const mapaProdutos = new Map(produtosExistentes?.map((p: any) => [p.nome.toUpperCase().trim(), p]))

        // 2. Processar lote
        for (const lente of lentes) {
            const nomeChave = lente.nome_completo.toUpperCase().trim()
            
            // CORREÇÃO: Cast 'as any' aqui para resolver o erro "Property id does not exist on type {}"
            const produtoExistente = mapaProdutos.get(nomeChave) as any

            const payload = {
                tenant_id: profile.tenant_id,
                store_id: storeId,
                nome: lente.nome_completo,
                marca: lente.marca,
                tipo_produto: 'Lente',
                categoria: 'Lente Oftálmica',
                preco_venda: lente.preco_venda,
                preco_custo: lente.preco_custo,
                detalhes: {
                    ...lente.detalhes,
                    linha: lente.linha,
                    material: lente.material,
                    tipo_desenho: lente.tipo_lente,
                    importado_em: new Date().toISOString()
                },
                gerencia_estoque: false,
                estoque_atual: 0,
                estoque_minimo: 0,
                tem_grade: true
            }

            if (produtoExistente) {
                // ATUALIZAR
                // CORREÇÃO: Cast 'as any'
                const { error } = await (supabaseAdmin.from('products') as any)
                    .update({
                        preco_venda: payload.preco_venda,
                        preco_custo: payload.preco_custo,
                        detalhes: payload.detalhes
                    })
                    .eq('id', produtoExistente.id)
                
                if (error) errors.push(`Erro ao atualizar ${lente.nome_completo}: ${error.message}`)
                else updatedCount++
            } else {
                // CRIAR NOVO
                // CORREÇÃO: Cast 'as any'
                const { error } = await (supabaseAdmin.from('products') as any)
                    .insert(payload)
                
                if (error) errors.push(`Erro ao criar ${lente.nome_completo}: ${error.message}`)
                else createdCount++
            }
        }

        revalidatePath(`/dashboard/loja/${storeId}/cadastros`)
        
        return {
            success: true,
            message: 'Processamento concluído.',
            processed: lentes.length,
            created: createdCount,
            updated: updatedCount,
            errors
        }

    } catch (e: any) {
        console.error("Erro crítico na importação:", e)
        return { success: false, message: e.message, processed: 0, created: 0, updated: 0, errors: [e.message] }
    }
}

==================================================
ARQUIVO: .\src\lib\actions\lab-carnes.actions.ts
==================================================
'use server'

import { createClient } from '@/lib/supabase/server'; // Cliente Normal (Para pegar seu ID)
import { createClient as createAdmin } from '@supabase/supabase-js'; // Cliente Admin (Para gravar à força)
import { revalidatePath } from 'next/cache';

// --- CONFIGURAÇÃO ADMIN ---
const supabaseAdmin = createAdmin(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// --- TIPAGEM ---
interface NovoCarneDTO {
  venda_id: number;
  customer_id: number;
  store_id: number;
  tenant_id: string;
  valor_total: number;
  qtd_parcelas: number;
  data_primeiro_vencimento: string;
}

// 1. INVESTIGAR VENDA
export async function investigarVendaLab(vendaIdInput: string) {
  try {
    const { data: venda, error: erroVenda } = await supabaseAdmin
      .from('vendas')
      .select('*')
      .eq('id', vendaIdInput)
      .single();

    if (erroVenda || !venda) {
      return { success: false, message: `Venda ${vendaIdInput} não encontrada.` };
    }

    const { data: carne } = await supabaseAdmin
      .from('financiamento_loja')
      .select('*')
      .eq('venda_id', venda.id)
      .single();

    let parcelas: any[] = [];
    if (carne) {
      const { data: p } = await supabaseAdmin
        .from('financiamento_parcelas')
        .select('*')
        .eq('financiamento_id', carne.id)
        .order('numero_parcela');
      parcelas = p || [];
    }

    return { success: true, data: { venda, carne, parcelas } };

  } catch (error: any) {
    return { success: false, message: 'Erro interno: ' + error.message };
  }
}

// 2. CRIAR CARNÊ (COM DEBUG E USER ID)
// 2. CRIAR CARNÊ (CORRIGIDO: REMOVIDO CAMPO 'STATUS' DA CAPA)
// 2. CRIAR CARNÊ (CORRIGIDO: REMOVIDO STATUS DA CAPA E VENDA_ID DAS PARCELAS)
export async function criarCarneLab(dados: NovoCarneDTO) {
  console.log('--- [LAB] INICIANDO CRIAÇÃO ---');

  const supabase = createClient();
  const { data: { user } } = await supabase.auth.getUser();
  const userId = user?.id; 

  // A. Verificar duplicidade
  const { data: existente } = await supabaseAdmin
    .from('financiamento_loja')
    .select('id')
    .eq('venda_id', dados.venda_id)
    .single();

  if (existente) {
    return { success: false, message: 'Já existe um carnê. Exclua o anterior primeiro.' };
  }

  // B. Criar a Capa
  const payloadCapa = {
      tenant_id: dados.tenant_id,
      venda_id: dados.venda_id,
      customer_id: dados.customer_id,
      store_id: dados.store_id,
      valor_total_financiado: dados.valor_total,
      quantidade_parcelas: dados.qtd_parcelas,
      data_inicio: dados.data_primeiro_vencimento,
      // status: 'Ativo', <-- REMOVIDO (Erro anterior)
      created_at: new Date().toISOString(),
      created_by_user_id: userId,
      employee_id: dados.venda_id ? undefined : undefined 
  };

  const { data: capa, error: erroCapa } = await supabaseAdmin
    .from('financiamento_loja')
    .insert(payloadCapa)
    .select()
    .single();

  if (erroCapa) {
    console.error('[LAB ERRO CAPA]', erroCapa);
    return { 
      success: false, 
      message: `ERRO DE BANCO NA CAPA: ${erroCapa.message}` 
    };
  }

  // C. Calcular Parcelas
  const valorParcela = Number((dados.valor_total / dados.qtd_parcelas).toFixed(2));
  const diferenca = Number((dados.valor_total - (valorParcela * dados.qtd_parcelas)).toFixed(2));
  
  const parcelas = [];
  const dataBase = new Date(dados.data_primeiro_vencimento);

  for (let i = 1; i <= dados.qtd_parcelas; i++) {
    const valorReal = i === 1 ? valorParcela + diferenca : valorParcela;
    const vencimento = new Date(dataBase);
    if (i > 1) vencimento.setMonth(vencimento.getMonth() + (i - 1));

    parcelas.push({
      tenant_id: dados.tenant_id,
      financiamento_id: capa.id,
      // venda_id: dados.venda_id, <--- REMOVIDO: O erro diz que esta coluna não existe em parcelas
      store_id: dados.store_id,
      customer_id: dados.customer_id,
      numero_parcela: i,
      data_vencimento: vencimento.toISOString().split('T')[0],
      valor_parcela: valorReal,
      valor_pago: 0,
      status: 'Pendente'
    });
  }

  // D. Inserir Parcelas
  const { error: erroParcelas } = await supabaseAdmin
    .from('financiamento_parcelas')
    .insert(parcelas);

  if (erroParcelas) {
    console.error('[LAB ERRO PARCELAS]', erroParcelas);
    // Rollback: Se falhar na parcela, apaga a capa para não deixar lixo
    await supabaseAdmin.from('financiamento_loja').delete().eq('id', capa.id); 
    return { success: false, message: `ERRO NAS PARCELAS: ${erroParcelas.message}` };
  }

  // E. Atualizar Venda
  const { error: erroUpdate } = await supabaseAdmin
    .from('vendas')
    .update({ financiamento_id: capa.id })
    .eq('id', dados.venda_id);

  if (erroUpdate) {
     return { success: false, message: `ERRO AO VINCULAR VENDA: ${erroUpdate.message}` };
  }

  revalidatePath('/dashboard/lab-financeiro');
  return { success: true, message: 'Carnê criado com sucesso!' };
}

// 3. EXCLUSÃO COM RASTREAMENTO (SEM ZUMBIS)
export async function excluirCarneLab(financiamentoId: number, vendaId: number) {
  console.log(`--- [LAB] INICIANDO EXCLUSÃO DO CARNÊ ${financiamentoId} ---`);

  try {
    // PASSO 1: O MAIS IMPORTANTE - Desvincular a venda IMEDIATAMENTE
    console.log('[LAB DELETE] Passo 1: Libertando a Venda...');
    const { error: erroUpdate } = await supabaseAdmin
      .from('vendas')
      .update({ financiamento_id: null })
      .eq('id', vendaId);

    if (erroUpdate) {
      console.error('[LAB DELETE ERROR] Falha ao desvincular venda:', erroUpdate);
      return { success: false, message: 'ERRO CRÍTICO: O banco travou ao tentar soltar a venda. Abortando.' };
    }
    console.log('[LAB DELETE] Venda libertada com sucesso.');

    // PASSO 2: Apagar as parcelas
    console.log('[LAB DELETE] Passo 2: Apagando parcelas...');
    const { error: erroParcelas, count: qtdParcelas } = await supabaseAdmin
      .from('financiamento_parcelas')
      .delete({ count: 'exact' }) // Pede contagem de quantos apagou
      .eq('financiamento_id', financiamentoId);

    if (erroParcelas) {
        console.error('[LAB DELETE ERROR] Falha nas parcelas:', erroParcelas);
        return { success: false, message: 'Venda foi solta, mas erro ao apagar parcelas.' };
    }
    console.log(`[LAB DELETE] ${qtdParcelas} parcelas apagadas.`);

    // PASSO 3: Apagar a capa
    console.log('[LAB DELETE] Passo 3: Apagando a capa (Contrato)...');
    const { error: erroCapa } = await supabaseAdmin
      .from('financiamento_loja')
      .delete()
      .eq('id', financiamentoId);

    if (erroCapa) {
        console.error('[LAB DELETE ERROR] Falha na capa:', erroCapa);
        // Nota: As parcelas já foram, a venda já foi solta. Sobrou só a capa vazia.
        return { success: false, message: 'Venda solta, parcelas apagadas, mas a CAPA travou.' };
    }
    console.log('[LAB DELETE] Capa apagada. Limpeza completa.');

    revalidatePath('/dashboard/lab-financeiro');
    return { success: true, message: 'Carnê excluído e venda limpa com sucesso.' };

  } catch (error: any) {
    console.error('[LAB EXCEPTION]', error);
    return { success: false, message: 'Erro de exceção: ' + error.message };
  }
}



==================================================
ARQUIVO: .\src\lib\actions\lab.actions.ts
==================================================
// ARQUIVO: src/lib/actions/lab.actions.ts
'use server'

import { createAdminClient } from "@/lib/supabase/admin"
import { revalidatePath } from "next/cache"

export type LabOSResult = {
    id: number
    venda_id: number | null // <--- IMPORTANTE: Esse campo garante o redirecionamento
    created_at: string
    customer_name: string
    dependente_name?: string | null
    status: string
    // Campos de Rastreio
    dt_pedido_em: string | null
    dt_lente_chegou: string | null
    dt_montado_em: string | null
    dt_entregue_em: string | null
    lab_nome: string | null
    lab_pedido_por_id: number | null
}

export type EmployeeSimple = {
    id: number
    name: string
}

// 0. BUSCAR FUNCIONÁRIOS
export async function getEmployees(storeId: number): Promise<EmployeeSimple[]> {
    const supabase = createAdminClient()
    const { data } = await supabase
        .from('employees')
        .select('id, full_name')
        .eq('store_id', storeId)
        .eq('is_active', true)
        .order('full_name') as any
    
    return data?.map((e: any) => ({
        id: e.id,
        name: e.full_name
    })) || []
}

// 1. BUSCAR OS PARA RASTREIO
export async function searchOSForLab(storeId: number, query: string): Promise<LabOSResult[]> {
    const supabase = createAdminClient()
    const cleanQuery = query.trim()
    
    let results: any[] = []

    // ESTRATÉGIA A: BUSCA EXATA PELO ID DA OS
    if (!isNaN(Number(cleanQuery))) {
        const { data: byId } = await supabase
            .from('service_orders')
            .select(`
                id, venda_id, created_at, 
                dt_pedido_em, dt_lente_chegou, dt_montado_em, dt_entregue_em, lab_nome, lab_pedido_por_id,
                customers ( full_name ),
                dependentes ( full_name ),
                vendas ( status )
            `)
            .eq('store_id', storeId)
            .eq('id', cleanQuery) as any
        
        if (byId) results = [...results, ...byId]
    }

    // ESTRATÉGIA B: BUSCA POR NOME DO CLIENTE
    const { data: byCustomer } = await supabase
        .from('service_orders')
        .select(`
            id, venda_id, created_at,
            dt_pedido_em, dt_lente_chegou, dt_montado_em, dt_entregue_em, lab_nome, lab_pedido_por_id,
            customers!inner ( full_name ),
            dependentes ( full_name ),
            vendas ( status )
        `)
        .eq('store_id', storeId)
        .ilike('customers.full_name', `%${cleanQuery}%`)
        .order('created_at', { ascending: false })
        .limit(5) as any

    if (byCustomer) results = [...results, ...byCustomer]

    // ESTRATÉGIA C: BUSCA POR NOME DO DEPENDENTE
    try {
        const { data: byDependente } = await supabase
            .from('service_orders')
            .select(`
                id, venda_id, created_at,
                dt_pedido_em, dt_lente_chegou, dt_montado_em, dt_entregue_em, lab_nome, lab_pedido_por_id,
                customers ( full_name ),
                dependentes!inner ( full_name ),
                vendas ( status )
            `)
            .eq('store_id', storeId)
            .ilike('dependentes.full_name', `%${cleanQuery}%`)
            .order('created_at', { ascending: false })
            .limit(5) as any

        if (byDependente) results = [...results, ...byDependente]
    } catch (error) {
        console.log("Erro busca dependente:", error)
    }

    // REMOVER DUPLICATAS
    const uniqueMap = new Map()
    results.forEach(item => uniqueMap.set(item.id, item))
    const uniqueResults = Array.from(uniqueMap.values())

    return uniqueResults.map((os: any) => ({
        id: os.id,
        venda_id: os.venda_id, // <--- O SEGREDO ESTÁ AQUI
        created_at: os.created_at,
        customer_name: os.customers?.full_name || 'Consumidor',
        dependente_name: os.dependentes?.full_name || null,
        status: os.vendas?.status || 'Indefinido',
        dt_pedido_em: os.dt_pedido_em,
        dt_lente_chegou: os.dt_lente_chegou,
        dt_montado_em: os.dt_montado_em,
        dt_entregue_em: os.dt_entregue_em,
        lab_nome: os.lab_nome,
        lab_pedido_por_id: os.lab_pedido_por_id
    }))
}

// 2. SALVAR ATUALIZAÇÃO DO LABORATÓRIO
export async function updateLabTracking(osId: number, storeId: number, formData: FormData) {
    const supabase = createAdminClient()
    
    const updates = {
        dt_pedido_em: formData.get('dt_pedido_em')?.toString() || null,
        lab_nome: formData.get('lab_nome')?.toString() || null,
        dt_lente_chegou: formData.get('dt_lente_chegou')?.toString() || null,
        dt_montado_em: formData.get('dt_montado_em')?.toString() || null,
        dt_entregue_em: formData.get('dt_entregue_em')?.toString() || null,
        lab_pedido_por_id: formData.get('lab_pedido_por_id') ? Number(formData.get('lab_pedido_por_id')) : null
    }

    const { error } = await (supabase.from('service_orders') as any)
        .update(updates)
        .eq('id', osId)
        .eq('store_id', storeId)

    if (error) {
        console.error("Erro update lab:", error)
        return { success: false, message: 'Erro ao salvar rastreio.' }
    }

    revalidatePath(`/dashboard/loja/${storeId}`)
    return { success: true }
}

==================================================
ARQUIVO: .\src\lib\actions\payable.actions.ts
==================================================
// Caminho: src/lib/actions/payable.actions.ts
'use server'

import { createAdminClient, getProfileByAdmin } from '@/lib/supabase/admin'
import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { z } from 'zod'
import { Database } from '@/lib/database.types'

type Bill = Database['public']['Tables']['accounts_payable']['Row']

// ==============================================================================
// 1. LISTAR CONTAS (FILTRO POR MÊS)
// ==============================================================================
export async function getBills(storeId: number, dateStr?: string) {
    const supabaseAdmin = createAdminClient()
    
    // Define o intervalo do mês (Ex: 2024-11)
    const baseDate = dateStr ? new Date(dateStr) : new Date()
    const firstDay = new Date(baseDate.getFullYear(), baseDate.getMonth(), 1).toISOString()
    const lastDay = new Date(baseDate.getFullYear(), baseDate.getMonth() + 1, 0).toISOString()

    try {
        // CORREÇÃO: Cast 'as any' para select com relacionamento
        const { data, error } = await (supabaseAdmin
            .from('accounts_payable') as any)
            .select(`
                *,
                suppliers ( nome_fantasia )
            `)
            .eq('store_id', storeId)
            .gte('due_date', firstDay)
            .lte('due_date', lastDay)
            .order('due_date', { ascending: true })

        if (error) throw error
        return { success: true, data: data || [] }
    } catch (e: any) {
        return { success: false, message: e.message }
    }
}

// ==============================================================================
// 2. SALVAR CONTA (CRIAR / EDITAR)
// ==============================================================================
const BillSchema = z.object({
    id: z.coerce.number().optional(),
    store_id: z.coerce.number(),
    description: z.string().min(3, "Descrição obrigatória"),
    amount: z.coerce.number().min(0.01, "Valor inválido"),
    due_date: z.string().min(10, "Data inválida"),
    category: z.string().optional(),
    supplier_id: z.coerce.number().optional().nullable()
})

export async function saveBill(prevState: any, formData: FormData) {
    const supabaseAdmin = createAdminClient()
    const { data: { user } } = await createClient().auth.getUser()
    
    if (!user) return { success: false, message: 'Login necessário.' }
    
    // CORREÇÃO: Cast 'as any' no profile
    const profile = await getProfileByAdmin(user.id) as any
    
    if (!profile) return { success: false, message: 'Perfil inválido.' }

    const rawData = {
        id: formData.get('id'),
        store_id: profile.store_id,
        description: formData.get('description'),
        amount: formData.get('amount'),
        due_date: formData.get('due_date'),
        category: formData.get('category'),
        supplier_id: formData.get('supplier_id')
    }

    const val = BillSchema.safeParse(rawData)
    if (!val.success) return { success: false, message: 'Dados inválidos.' }

    const { id, ...billData } = val.data

    try {
        // Cast as any no tenant_id para garantir
        const payload = {
            ...billData,
            tenant_id: profile.tenant_id,
            created_by_user_id: user.id
        }

        if (id) {
            // CORREÇÃO: Cast 'as any' no update
            await (supabaseAdmin.from('accounts_payable') as any).update(payload).eq('id', id)
        } else {
            // CORREÇÃO: Cast 'as any' no insert
            await (supabaseAdmin.from('accounts_payable') as any).insert(payload)
        }

        revalidatePath(`/dashboard/loja/${profile.store_id}/financeiro/contas`)
        return { success: true, message: 'Conta salva com sucesso!' }
    } catch (e: any) {
        return { success: false, message: e.message }
    }
}

// ==============================================================================
// 3. PAGAR CONTA (BAIXA + INTEGRAÇÃO COM CAIXA)
// ==============================================================================
const PayBillSchema = z.object({
    bill_id: z.coerce.number(),
    store_id: z.coerce.number(),
    amount_paid: z.coerce.number(),
    payment_date: z.string(),
    source: z.enum(['Caixa', 'Banco']) 
})

export async function payBill(prevState: any, formData: FormData) {
    const supabaseAdmin = createAdminClient()
    const { data: { user } } = await createClient().auth.getUser()
    
    // CORREÇÃO: Cast 'as any' no profile
    const profile = await getProfileByAdmin(user!.id) as any

    const input = {
        bill_id: formData.get('bill_id'),
        store_id: profile?.store_id,
        amount_paid: formData.get('amount_paid'),
        payment_date: formData.get('payment_date'),
        source: formData.get('source')
    }

    const val = PayBillSchema.safeParse(input)
    if (!val.success) return { success: false, message: 'Dados de pagamento inválidos.' }

    const { bill_id, store_id, amount_paid, payment_date, source } = val.data

    try {
        // A. Se a fonte for CAIXA, precisamos criar uma SANGRIA automática
        if (source === 'Caixa') {
            // 1. Busca o caixa aberto HOJE
            const hoje = new Date()
            const dataInicioHoje = new Date(hoje.setHours(0,0,0,0)).toISOString()

            // CORREÇÃO: Cast 'as any' no select do caixa
            const { data: caixaAberto } = await (supabaseAdmin
                .from('caixa_diario') as any)
                .select('id')
                .eq('store_id', store_id)
                .eq('status', 'Aberto')
                .gte('created_at', dataInicioHoje)
                .maybeSingle()

            if (!caixaAberto) {
                return { success: false, message: 'Erro: Não há caixa aberto para realizar pagamento em dinheiro.' }
            }

            // 2. Busca descrição da conta
            // CORREÇÃO: Cast 'as any' no select da conta
            const { data: conta } = await (supabaseAdmin.from('accounts_payable') as any)
                .select('description')
                .eq('id', bill_id)
                .single()

            // 3. Insere a Saída no Caixa
            // CORREÇÃO: Cast 'as any' no insert da movimentação
            await (supabaseAdmin.from('caixa_movimentacoes') as any).insert({
                tenant_id: profile?.tenant_id,
                store_id: store_id,
                caixa_id: caixaAberto.id,
                usuario_id: user?.id,
                tipo: 'Saida',
                valor: amount_paid,
                descricao: `Pagto Conta: ${conta?.description || 'Despesa'}`,
                categoria: 'Despesa Operacional',
                forma_pagamento: 'Dinheiro'
            })
        }

        // B. Atualiza o Status da Conta para PAGO
        // CORREÇÃO: Cast 'as any' no update da conta
        await (supabaseAdmin.from('accounts_payable') as any).update({
            status: 'Pago',
            amount_paid: amount_paid,
            payment_date: payment_date,
            updated_at: new Date().toISOString()
        }).eq('id', bill_id)

        revalidatePath(`/dashboard/loja/${store_id}/financeiro/contas`)
        
        if (source === 'Caixa') {
            revalidatePath(`/dashboard/loja/${store_id}/financeiro/caixa`)
        }

        return { success: true, message: 'Pagamento registrado com sucesso!' }

    } catch (e: any) {
        return { success: false, message: e.message }
    }
}

// ==============================================================================
// 4. EXCLUIR CONTA
// ==============================================================================
export async function deleteBill(billId: number, storeId: number) {
    const supabaseAdmin = createAdminClient()
    try {
        // CORREÇÃO: Cast 'as any' no delete
        await (supabaseAdmin.from('accounts_payable') as any).delete().eq('id', billId)
        revalidatePath(`/dashboard/loja/${storeId}/financeiro/contas`)
        return { success: true, message: 'Conta removida.' }
    } catch (e: any) {
        return { success: false, message: e.message }
    }
}

==================================================
ARQUIVO: .\src\lib\actions\postsales.actions.ts
==================================================
// Caminho: src/lib/actions/postsales.actions.ts
'use server'

import { createAdminClient, getProfileByAdmin } from '@/lib/supabase/admin'
import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'

// TIPO ATUALIZADO COM DADOS FINANCEIROS
export type PostSaleQueueItem = {
  os_id: number
  venda_id: number // Novo
  dt_entregue: string
  dias_desde_entrega: number
  titular_nome: string
  titular_tel: string | null
  dependente_nome: string | null
  resumo_lente: string
  post_sales_id: number | null
  status: string
  // Dados Financeiros
  valor_final: number
  valor_restante: number
  status_venda: string
  tem_carne: boolean
}

export type Interaction = {
  id: number
  created_at: string
  tipo_contato: string
  resumo: string
  registrado_por_id: string
}

// 1. BUSCAR FILA DE PÓS-VENDA (ATUALIZADA)
export async function getFilaPosVenda(storeId: number) {
  const supabaseAdmin = createAdminClient()
  
  const hoje = new Date()
  // Regra: Entregue há pelo menos 7 dias
  const dataCorte = new Date(hoje.setDate(hoje.getDate() - 7)).toISOString()

  try {
    // CORREÇÃO: Cast 'as any' para permitir joins complexos (vendas, post_sales)
    const { data: oss, error } = await (supabaseAdmin
      .from('service_orders') as any)
      .select(`
        id, 
        dt_entregue_em, 
        receita_longe_od_esferico, 
        receita_adicao,
        customers ( full_name, fone_movel ),
        dependente_id,
        dependentes ( full_name ),
        post_sales ( id, status ),
        vendas ( id, valor_final, valor_restante, status, financiamento_id ) 
      `)
      .eq('store_id', storeId)
      .not('dt_entregue_em', 'is', null)
      .lte('dt_entregue_em', dataCorte) 
      .order('dt_entregue_em', { ascending: true })

    if (error) {
        console.error("Erro Supabase:", error.message)
        return []
    }
    if (!oss) return []

    const fila: PostSaleQueueItem[] = (oss as any[])
      .filter((os: any) => {
        const ps = os.post_sales?.[0]
        return ps?.status !== 'Concluido'
      })
      .map((os: any) => {
        const entregueEm = new Date(os.dt_entregue_em).getTime()
        const diffDias = Math.floor((Date.now() - entregueEm) / (1000 * 60 * 60 * 24))
        const ps = os.post_sales?.[0]
        
        // Extração Segura da Venda
        const venda = os.vendas || {}

        return {
          os_id: os.id,
          venda_id: venda.id, // Novo
          dt_entregue: os.dt_entregue_em,
          dias_desde_entrega: diffDias,
          titular_nome: os.customers?.full_name || 'Cliente',
          titular_tel: os.customers?.fone_movel || null,
          dependente_nome: os.dependentes?.full_name || os.customers?.full_name || 'Mesmo',
          resumo_lente: os.receita_adicao ? 'Multifocal' : 'Visão Simples',
          post_sales_id: ps?.id || null,
          status: ps?.status || 'Pendente',
          // Mapping Financeiro
          valor_final: venda.valor_final || 0,
          valor_restante: venda.valor_restante || 0,
          status_venda: venda.status || 'Desconhecido',
          tem_carne: !!venda.financiamento_id
        }
      })

    return fila
  } catch (e) {
    console.error("Erro crítico fila pos venda:", e)
    return []
  }
}

export async function saveInteraction(formData: FormData) {
  const supabase = createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return { success: false, message: 'Login necessário' }

  // CORREÇÃO: Cast 'as any' no profile para acessar tenant_id
  const profile = await getProfileByAdmin(user.id) as any
  if (!profile?.tenant_id) return { success: false, message: 'Perfil erro' }

  const osId = parseInt(formData.get('os_id') as string)
  const tipo = formData.get('tipo') as string
  const resumo = formData.get('resumo') as string
  
  let postSalesId = formData.get('post_sales_id') && formData.get('post_sales_id') !== 'null' 
    ? parseInt(formData.get('post_sales_id') as string) 
    : null

  const supabaseAdmin = createAdminClient()

  try {
    if (!postSalesId) {
      // CORREÇÃO: Cast 'as any' no insert em post_sales
      const { data: novoPai, error } = await (supabaseAdmin
        .from('post_sales') as any)
        .insert({
          tenant_id: profile.tenant_id,
          store_id: profile.store_id!,
          service_order_id: osId,
          status: 'Em Acompanhamento'
        })
        .select('id')
        .single()
      if (error || !novoPai) throw new Error("Erro ao iniciar")
      postSalesId = novoPai.id
    } else {
      // CORREÇÃO: Cast 'as any' no update
      await (supabaseAdmin.from('post_sales') as any)
        .update({ status: 'Em Acompanhamento', updated_at: new Date().toISOString() })
        .eq('id', postSalesId)
    }

    // CORREÇÃO: Cast 'as any' no insert da interação
    await (supabaseAdmin.from('post_sales_interactions') as any).insert({
      tenant_id: profile.tenant_id,
      store_id: profile.store_id!,
      post_sales_id: postSalesId,
      registrado_por_id: user.id,
      tipo_contato: tipo,
      resumo: resumo
    })

    revalidatePath(`/dashboard/loja/${profile.store_id}/pos-venda`)
    return { success: true, message: 'Interação registrada.' }
  } catch (e: any) { return { success: false, message: e.message } }
}

export async function concludePostSale(formData: FormData) {
  const supabaseAdmin = createAdminClient()
  const psId = parseInt(formData.get('post_sales_id') as string)
  const storeId = parseInt(formData.get('store_id') as string)

  try {
    // CORREÇÃO: Cast 'as any' no update
    await (supabaseAdmin.from('post_sales') as any).update({
        status: 'Concluido',
        avaliacao_cliente: parseInt(formData.get('nota') as string),
        observacoes_finais: formData.get('obs') as string,
        updated_at: new Date().toISOString()
      }).eq('id', psId)

    revalidatePath(`/dashboard/loja/${storeId}/pos-venda`)
    return { success: true, message: 'Concluído!' }
  } catch (e: any) { return { success: false, message: e.message } }
}

export async function getInteractions(postSalesId: number | null) {
    if (!postSalesId) return []
    const supabaseAdmin = createAdminClient()
    
    // CORREÇÃO: Cast 'as any' no select
    const { data } = await (supabaseAdmin.from('post_sales_interactions') as any)
        .select('*')
        .eq('post_sales_id', postSalesId)
        .order('created_at', { ascending: false })
    
    return data as Interaction[]
}

// ==============================================================================
// NOVA ACTION: BUSCAR DETALHES COMPLETOS (RAIO-X) PARA O MODAL
// ==============================================================================
export async function getPostSaleDetails(osId: number) {
  const supabaseAdmin = createAdminClient()
  try {
    // CORREÇÃO: Cast 'as any' para permitir joins aninhados
    const { data, error } = await (supabaseAdmin
      .from('service_orders') as any)
      .select(`
        *,
        customers ( full_name ),
        dependentes ( full_name ),
        vendas (
          id, valor_total, valor_final, valor_restante, status, created_at,
          venda_itens ( item_tipo, descricao, valor_unitario )
        )
      `)
      .eq('id', osId)
      .single()

    if (error) throw error
  
    return { success: true, data }
  } catch (e: any) {
    console.error("Erro detalhes pos-venda:", e)
    return { success: false, message: e.message }
  }
}

==================================================
ARQUIVO: .\src\lib\actions\reports.actions.ts
==================================================
'use server'

import { createAdminClient } from '@/lib/supabase/admin'

export type VendaRelatorioItem = {
  id: number
  data: string
  cliente: string
  vendedor: string
  itens_resumo: string
  qtd_itens: number
  status: string
  valor_total: number
  valor_desconto: number
  valor_final: number
  valor_pago: number
  saldo_devedor: number
  tem_carne: boolean
}

export async function getRelatorioVendas(storeId: number, dataInicio: string, dataFim: string) {
  const supabase = createAdminClient()

  // Ajusta o fim do dia para a data final
  const fimDoDia = new Date(dataFim)
  fimDoDia.setHours(23, 59, 59, 999)

  try {
    const { data: vendas, error } = await supabase
      .from('vendas')
      .select(`
        id, created_at, status, valor_total, valor_desconto, valor_final, valor_restante, financiamento_id,
        customers ( full_name ),
        employees ( full_name ),
        venda_itens ( descricao )
      `)
      .eq('store_id', storeId)
      .gte('created_at', dataInicio)
      .lte('created_at', fimDoDia.toISOString())
      .order('created_at', { ascending: false })

    if (error) throw error
    if (!vendas) return []

    // Achata os dados para a tabela
    const relatorio: VendaRelatorioItem[] = vendas.map((v: any) => {
      const pago = (v.valor_final || 0) - (v.valor_restante || 0)
      const itensDesc = v.venda_itens?.map((i: any) => i.descricao).join(', ') || ''
      
      return {
        id: v.id,
        data: v.created_at,
        cliente: v.customers?.full_name || 'Consumidor Final',
        vendedor: v.employees?.full_name || '-',
        itens_resumo: itensDesc.length > 50 ? itensDesc.substring(0, 50) + '...' : itensDesc,
        qtd_itens: v.venda_itens?.length || 0,
        status: v.status,
        valor_total: v.valor_total || 0,
        valor_desconto: v.valor_desconto || 0,
        valor_final: v.valor_final || 0,
        valor_pago: pago,
        saldo_devedor: v.valor_restante || 0,
        tem_carne: !!v.financiamento_id
      }
    })

    return relatorio
  } catch (error) {
    console.error("Erro relatório:", error)
    return []
  }
}

==================================================
ARQUIVO: .\src\lib\actions\return.actions.ts
==================================================
// ARQUIVO: src/lib/actions/return.actions.ts
'use server'

import { createAdminClient, getProfileByAdmin } from '@/lib/supabase/admin'
import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { z } from 'zod'
import { addCredit } from './wallet.actions' // Reutilizamos a action da carteira

// Schema para validar os itens selecionados
const ReturnItemSchema = z.object({
    venda_item_id: z.coerce.number(),
    product_id: z.coerce.number(),
    quantidade: z.coerce.number().min(1),
    valor_unitario: z.coerce.number(),
    condicao: z.enum(['Intacto', 'Defeito', 'Sobra']),
    // Dados específicos para Sobra de Lente
    detalhes_sobra: z.object({
        diametro: z.coerce.number().optional(),
        olho: z.string().optional() // 'OD' ou 'OE'
    }).optional()
})

const ProcessReturnSchema = z.object({
    store_id: z.coerce.number(),
    venda_id: z.coerce.number(),
    customer_id: z.coerce.number(),
    employee_id: z.coerce.number(), // Quem autorizou (PIN)
    tipo_reembolso: z.enum(['Carteira', 'Estorno']),
    itens: z.array(ReturnItemSchema)
})

export type ReturnActionResult = {
    success: boolean
    message: string
}

export async function processarDevolucao(prevState: any, formData: FormData): Promise<ReturnActionResult> {
    const supabaseAdmin = createAdminClient()
    const { data: { user } } = await createClient().auth.getUser()
    
    if (!user) return { success: false, message: 'Usuário não logado.' }
    
    // CORREÇÃO: Cast 'as any' para garantir acesso ao tenant_id
    const profile = await getProfileByAdmin(user.id) as any
    if (!profile) return { success: false, message: 'Perfil inválido.' }

    // Parse do JSON enviado pelo form
    const rawItens = JSON.parse(formData.get('itens_json') as string)
    
    const inputData = {
        store_id: formData.get('store_id'),
        venda_id: formData.get('venda_id'),
        customer_id: formData.get('customer_id'),
        employee_id: formData.get('employee_id'),
        tipo_reembolso: formData.get('tipo_reembolso'),
        itens: rawItens
    }

    const validated = ProcessReturnSchema.safeParse(inputData)
    
    if (!validated.success) {
        console.error(validated.error)
        return { success: false, message: 'Dados inválidos.' }
    }

    const { store_id, venda_id, customer_id, employee_id, tipo_reembolso, itens } = validated.data
    const totalReembolso = itens.reduce((acc, item) => acc + (item.valor_unitario * item.quantidade), 0)

    try {
        // 1. PROCESSAR ITENS (ESTOQUE)
        for (const item of itens) {
            
            // A: Devolução Intacta (Volta pro estoque normal)
            if (item.condicao === 'Intacto') {
                // CORREÇÃO: Cast 'as any' para RPC
                await (supabaseAdmin as any).rpc('increment_stock', { 
                    p_product_id: item.product_id, 
                    p_quantity: item.quantidade,
                    p_new_cost: null 
                })
                
                // Log Movimentação
                // CORREÇÃO: Cast 'as any' para insert em stock_movements
                await (supabaseAdmin.from('stock_movements') as any).insert({
                    tenant_id: profile.tenant_id,
                    store_id,
                    product_id: item.product_id,
                    tipo: 'Devolucao',
                    quantidade: item.quantidade,
                    motivo: `Devolução Venda #${venda_id}`,
                    related_venda_id: venda_id,
                    employee_id,
                    registrado_por_id: user.id
                })
            }
            // B: Sobra de Lente (Cria variante nova)
            else if (item.condicao === 'Sobra' && item.detalhes_sobra?.diametro) {
                // Busca dados originais do produto para copiar (grau, etc)
                // CORREÇÃO: Cast 'as any' para select em products
                const { data: prodOriginal } = await (supabaseAdmin.from('products') as any).select('*').eq('id', item.product_id).single()
                
                if (prodOriginal) {
                    // Cria Variante de Sobra
                    // CORREÇÃO: Cast 'as any' para insert em product_variants
                    const { data: novaSobra } = await (supabaseAdmin.from('product_variants') as any).insert({
                        product_id: item.product_id,
                        store_id,
                        tenant_id: profile.tenant_id,
                        nome_variante: `Sobra ${item.detalhes_sobra.olho} Ø${item.detalhes_sobra.diametro}`,
                        esferico: null, 
                        is_sobra: true,
                        diametro: item.detalhes_sobra.diametro,
                        olho: item.detalhes_sobra.olho,
                        estoque_atual: item.quantidade
                    }).select().single()

                    if (novaSobra) {
                         // Log Entrada de Sobra
                        await (supabaseAdmin.from('stock_movements') as any).insert({
                            tenant_id: profile.tenant_id,
                            store_id,
                            product_id: item.product_id,
                            variant_id: novaSobra.id,
                            tipo: 'Entrada', // Entra como sobra
                            quantidade: item.quantidade,
                            motivo: `Sobra de Devolução Venda #${venda_id}`,
                            related_venda_id: venda_id,
                            employee_id,
                            registrado_por_id: user.id
                        })
                    }
                }
            }
            // C: Defeito (Perda direta)
            else if (item.condicao === 'Defeito') {
                await (supabaseAdmin.from('stock_movements') as any).insert({
                    tenant_id: profile.tenant_id,
                    store_id,
                    product_id: item.product_id,
                    tipo: 'Perda',
                    quantidade: item.quantidade,
                    motivo: `Defeito na Devolução Venda #${venda_id}`,
                    related_venda_id: venda_id,
                    employee_id,
                    registrado_por_id: user.id
                })
            }
        }

        // 2. FINANCEIRO
        if (tipo_reembolso === 'Carteira') {
            const fdWallet = new FormData()
            fdWallet.append('store_id', store_id.toString())
            fdWallet.append('customer_id', customer_id.toString())
            fdWallet.append('amount', totalReembolso.toString())
            fdWallet.append('description', `Crédito por devolução Venda #${venda_id}`)
            fdWallet.append('employee_id', employee_id.toString())
            fdWallet.append('related_venda_id', venda_id.toString())
            
            await addCredit(fdWallet)
        } 
        else if (tipo_reembolso === 'Estorno') {
            // Se for estorno, registramos uma saída no caixa (sangria técnica) ou apenas log
        }

        // 3. ATUALIZAR STATUS DA VENDA
        // CORREÇÃO: Cast 'as any' para update em vendas
        await (supabaseAdmin.from('vendas') as any)
            .update({ status: 'Devolvida' }) 
            .eq('id', venda_id)

        // 4. ESTORNO DE COMISSÃO
        // Busca comissão original
        // CORREÇÃO: Cast 'as any' para select e update em commissions
        const { data: comissao } = await (supabaseAdmin
            .from('commissions') as any)
            .select('id')
            .eq('venda_id', venda_id)
            .eq('status', 'Pendente') 
            .maybeSingle()
        
        if (comissao) {
            await (supabaseAdmin
                .from('commissions') as any)
                .update({ status: 'Estornado', reversal_reason: 'Devolução de Venda' })
                .eq('id', comissao.id)
        }

        revalidatePath(`/dashboard/loja/${store_id}/vendas/${venda_id}`)
        return { success: true, message: 'Devolução processada com sucesso.' }

    } catch (e: any) {
        console.error("Erro devolucao:", e)
        return { success: false, message: e.message }
    }
}

==================================================
ARQUIVO: .\src\lib\actions\settings.actions.ts
==================================================
// ARQUIVO: src/lib/actions/settings.actions.ts
'use server'

import { createAdminClient, getProfileByAdmin } from '@/lib/supabase/admin'
import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { z } from 'zod'

// --- DEFINIÇÃO DO FORMATO DAS CONFIGURAÇÕES ---
export type StoreSettings = {
    print_receipt_template: 'thermal_80mm' | 'thermal_58mm' | 'a4_simple'
    print_os_template: 'a4_full' | 'a4_preprinted' | 'thermal_80mm'
    print_show_logo: boolean
    print_show_price_os: boolean
    custom_message_receipt?: string
}

// Valores padrão
const DEFAULT_SETTINGS: StoreSettings = {
    print_receipt_template: 'thermal_80mm',
    print_os_template: 'a4_full',
    print_show_logo: true,
    print_show_price_os: true,
    custom_message_receipt: 'Obrigado pela preferência!'
}

// --- 1. BUSCAR CONFIGURAÇÕES ---
export async function getStoreSettings(storeId: number): Promise<StoreSettings> {
    const supabaseAdmin = createAdminClient()

    try {
        // CORREÇÃO: Cast 'as any' para garantir leitura da coluna settings
        const { data, error } = await (supabaseAdmin
            .from('stores') as any)
            .select('settings')
            .eq('id', storeId)
            .single()

        if (error || !data) return DEFAULT_SETTINGS

        const savedSettings = data.settings as Partial<StoreSettings> || {}
        
        return {
            ...DEFAULT_SETTINGS,
            ...savedSettings
        }

    } catch (e) {
        console.error("Erro ao buscar settings:", e)
        return DEFAULT_SETTINGS
    }
}

// --- 2. SALVAR CONFIGURAÇÕES ---
const SettingsSchema = z.object({
    store_id: z.coerce.number(),
    print_receipt_template: z.enum(['thermal_80mm', 'thermal_58mm', 'a4_simple']),
    print_os_template: z.enum(['a4_full', 'a4_preprinted', 'thermal_80mm']),
    print_show_logo: z.coerce.boolean(),
    print_show_price_os: z.coerce.boolean(),
    custom_message_receipt: z.string().optional()
})

export async function updateStoreSettings(prevState: any, formData: FormData) {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user) return { success: false, message: 'Usuário não autenticado.' }
    
    // CORREÇÃO: Cast 'as any' para garantir acesso ao role
    const profile = await getProfileByAdmin(user.id) as any
    const role = profile?.role

    if (role !== 'admin' && role !== 'manager') {
        return { success: false, message: 'Permissão negada. Apenas gerentes alteram configurações.' }
    }

    // Prepara dados
    const rawData = {
        store_id: formData.get('store_id'),
        print_receipt_template: formData.get('print_receipt_template'),
        print_os_template: formData.get('print_os_template'),
        print_show_logo: formData.get('print_show_logo') === 'on',
        print_show_price_os: formData.get('print_show_price_os') === 'on',
        custom_message_receipt: formData.get('custom_message_receipt')
    }

    const validated = SettingsSchema.safeParse(rawData)

    if (!validated.success) {
        return { success: false, message: 'Dados inválidos.' }
    }

    const { store_id, ...newSettings } = validated.data
    const supabaseAdmin = createAdminClient()

    try {
        const current = await getStoreSettings(store_id)
        
        const updatedSettings = {
            ...current,
            ...newSettings
        }

        // CORREÇÃO: Cast 'as any' para update na coluna settings
        await (supabaseAdmin
            .from('stores') as any)
            .update({ settings: updatedSettings })
            .eq('id', store_id)

        revalidatePath(`/dashboard/loja/${store_id}/config`)
        return { success: true, message: 'Configurações de impressão salvas!' }

    } catch (e: any) {
        return { success: false, message: e.message }
    }
}

==================================================
ARQUIVO: .\src\lib\actions\stock.actions.ts
==================================================
// ARQUIVO: src/lib/actions/stock.actions.ts
'use server'

import { createClient } from '@/lib/supabase/server'
import { createAdminClient, getProfileByAdmin } from '@/lib/supabase/admin'
import { revalidatePath } from 'next/cache'
import { z } from 'zod'

// 1. ATUALIZAÇÃO DO SCHEMA (CORRIGIDO)
const MovimentoSchema = z.object({
  store_id: z.coerce.number(),
  // CORREÇÃO: Removido o objeto { required_error: ... } que causava o erro
  employee_id: z.coerce.number(), 
  product_id: z.coerce.number(),
  variant_id: z.coerce.number().optional().nullable(),
  tipo: z.enum(['Entrada', 'Saida', 'Perda', 'Ajuste', 'Devolucao', 'Brinde']),
  quantidade: z.coerce.number().min(1, "A quantidade deve ser maior que zero."),
  motivo: z.string().min(3, "O motivo é obrigatório."),
  // --- NOVOS CAMPOS PARA FLUXO 2 (PERDA/SOBRA) ---
  related_venda_id: z.coerce.number().optional().nullable(),
  sobra_detalhes: z.object({
      diametro: z.coerce.number(),
      olho: z.string()
  }).optional().nullable()
})

export type StockActionResult = {
  success: boolean
  message: string
}

export async function registrarMovimentacao(
  prevState: StockActionResult,
  formData: FormData
): Promise<StockActionResult> {
  const supabase = createClient()
  
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return { success: false, message: 'Usuário não autenticado.' }

  // Cast 'as any' para garantir acesso a props do perfil
  const profile = await getProfileByAdmin(user.id) as any
  if (!profile) return { success: false, message: 'Perfil não encontrado.' }

  // 2. CAPTURA DOS DADOS
  const rawData = {
    store_id: profile.store_id,
    employee_id: formData.get('employee_id'), 
    product_id: formData.get('product_id'),
    variant_id: formData.get('variant_id'),
    tipo: formData.get('tipo'),
    quantidade: formData.get('quantidade'),
    motivo: formData.get('motivo'),
    // Captura novos campos
    related_venda_id: formData.get('related_venda_id'),
    sobra_detalhes: formData.get('sobra_detalhes') ? JSON.parse(formData.get('sobra_detalhes') as string) : null
  }

  const validated = MovimentoSchema.safeParse(rawData)

  if (!validated.success) {
    console.error("Erro Validação Zod:", validated.error.flatten().fieldErrors)
    return { 
      success: false, 
      message: 'Dados inválidos. Verifique o console ou contate suporte.' 
    }
  }

  const { 
    product_id, variant_id, tipo, quantidade, motivo, store_id, employee_id,
    related_venda_id, sobra_detalhes 
  } = validated.data

  // 3. LÓGICA DE SINAL
  let multiplicador = 1
  if (['Saida', 'Perda', 'Brinde'].includes(tipo)) {
    multiplicador = -1
  }

  const deltaEstoque = quantidade * multiplicador

  const supabaseAdmin = createAdminClient()

  try {
    // Busca Produto
    // Cast 'as any' para select em products
    const { data: produto } = await (supabaseAdmin
        .from('products') as any)
        .select('estoque_atual, preco_custo, detalhes')
        .eq('id', product_id)
        .single()

    if (!produto) return { success: false, message: 'Produto não encontrado.' }

    let estoqueAtual = produto.estoque_atual
    
    // Atualiza Estoque
    if (variant_id) {
        // Cast 'as any' para select em product_variants
        const { data: variant } = await (supabaseAdmin
            .from('product_variants') as any)
            .select('estoque_atual')
            .eq('id', variant_id)
            .single()
        
        if (variant) estoqueAtual = variant.estoque_atual

        // Cast 'as any' para update em product_variants
        await (supabaseAdmin.from('product_variants') as any)
            .update({ estoque_atual: estoqueAtual + deltaEstoque })
            .eq('id', variant_id)
        
        // Cast 'as any' para RPC
        await (supabaseAdmin as any).rpc('increment_stock', { 
            p_product_id: product_id, 
            p_quantity: deltaEstoque,
            p_new_cost: null 
        })
    } else {
         // Cast 'as any' para update em products
         await (supabaseAdmin.from('products') as any)
            .update({ estoque_atual: estoqueAtual + deltaEstoque })
            .eq('id', product_id)
    }

    // 4. GRAVAÇÃO DA MOVIMENTAÇÃO PRINCIPAL
    // Cast 'as any' para insert em stock_movements
    const { error: insertError } = await (supabaseAdmin.from('stock_movements') as any).insert({
        tenant_id: profile.tenant_id,
        store_id: store_id,
        product_id: product_id,
        variant_id: variant_id || null,
        tipo: tipo,
        quantidade: quantidade,
        motivo: motivo,
        custo_unitario_momento: produto.preco_custo,
        
        registrado_por_id: user.id,   // Usuário do Sistema
        employee_id: employee_id,     // Quem autorizou (PIN)
        related_venda_id: related_venda_id || null,
        
        created_at: new Date().toISOString()
    })

    if (insertError) throw insertError

    // --- LÓGICA NOVA: SE FOR PERDA E GEROU SOBRA ---
    if (tipo === 'Perda' && sobra_detalhes && sobra_detalhes.diametro) {
        // A. Cria a Variante de Sobra (Custo Zero)
        // Cast 'as any' para insert em product_variants com campos novos
        const { data: novaSobra } = await (supabaseAdmin.from('product_variants') as any).insert({
            product_id: product_id,
            store_id: store_id,
            tenant_id: profile.tenant_id,
            nome_variante: `Sobra ${sobra_detalhes.olho} Ø${sobra_detalhes.diametro} (Recup. Quebra)`,
            
            esferico: null, 
            cilindrico: null,
            
            is_sobra: true,
            diametro: sobra_detalhes.diametro,
            olho: sobra_detalhes.olho,
            estoque_atual: 1, 
        }).select().single()

        if (novaSobra) {
            // B. Registra a Entrada da Sobra no Histórico
            // Cast 'as any' para insert em stock_movements
            await (supabaseAdmin.from('stock_movements') as any).insert({
                tenant_id: profile.tenant_id,
                store_id: store_id,
                product_id: product_id,
                variant_id: novaSobra.id,
                tipo: 'Entrada',
                quantidade: 1,
                motivo: `Sobra gerada da quebra/perda (Origem: Venda #${related_venda_id || 'N/A'})`,
                custo_unitario_momento: 0, 
                registrado_por_id: user.id,
                employee_id: employee_id,
                related_venda_id: related_venda_id || null
            })
        }
    }
    // -----------------------------------------------

    revalidatePath(`/dashboard/loja/${store_id}/estoque/movimentacoes`)
    revalidatePath(`/dashboard/loja/${store_id}/cadastros`)
    
    return { success: true, message: `Movimentação (${tipo}) registrada com sucesso!` }

  } catch (error: any) {
    console.error('Erro Movimentação:', error)
    return { success: false, message: error.message }
  }
}

// TIPOS PARA O FILTRO
export type StockFilters = {
    dataInicio?: string
    dataFim?: string
    tipo?: string
    busca?: string
}

export async function getStockMovements(storeId: number, filters?: StockFilters) {
    const supabaseAdmin = createAdminClient()
    
    // Cast 'as any' para select em stock_movements
    let query = (supabaseAdmin
        .from('stock_movements') as any)
        .select(`
            id, created_at, tipo, quantidade, motivo,
            products ( nome, codigo_barras ),
            product_variants ( nome_variante ),
            employees ( full_name )
        `) 
        .eq('store_id', storeId)
        .order('created_at', { ascending: false })
        .limit(100)

    if (filters?.dataInicio) {
        const inicioBrasil = `${filters.dataInicio}T00:00:00-03:00`
        query = query.gte('created_at', inicioBrasil)
    }
    
    if (filters?.dataFim) {
        const fimBrasil = `${filters.dataFim}T23:59:59-03:00`
        query = query.lte('created_at', fimBrasil)
    }

    if (filters?.tipo && filters.tipo !== 'Todos') {
        query = query.eq('tipo', filters.tipo)
    }

    if (filters?.busca) {
        query = query.ilike('motivo', `%${filters.busca}%`)
    }
    
    const { data, error } = await query
    
    if (error) {
        console.error("Erro ao buscar histórico:", error)
        return []
    }

    return data || []
}

// ================================================================
// 3. ACTION: BUSCAR SOBRAS COMPATÍVEIS
// ================================================================
export type LeftoverMatch = {
    id: number
    nome_variante: string
    diametro: number
    olho: string
    estoque: number
}

export async function findCompatibleLeftover(
    storeId: number,
    esferico: string,
    cilindrico: string,
    diametroMinimo?: number
): Promise<LeftoverMatch[]> {
    const supabase = createAdminClient()

    const esf = parseFloat(esferico.replace(',', '.'))
    const cil = parseFloat(cilindrico.replace(',', '.'))

    if (isNaN(esf) || isNaN(cil)) return []

    // Cast 'as any' para select em product_variants com campos novos (is_sobra, diametro, etc)
    let query = (supabase
        .from('product_variants') as any)
        .select('id, nome_variante, diametro, olho, estoque_atual')
        .eq('store_id', storeId)
        .eq('is_sobra', true) 
        .gt('estoque_atual', 0) 
        .eq('esferico', esf)
        .eq('cilindrico', cil)

    if (diametroMinimo && diametroMinimo > 0) {
        query = query.gte('diametro', diametroMinimo)
    }

    const { data, error } = await query

    if (error) {
        console.error('Erro ao buscar sobras:', error)
        return []
    }

    return data.map((item: any) => ({
        id: item.id,
        nome_variante: item.nome_variante,
        diametro: item.diametro,
        olho: item.olho,
        estoque: item.estoque_atual
    }))
}

==================================================
ARQUIVO: .\src\lib\actions\store.actions.ts
==================================================
// ARQUIVO: src/lib/actions/store.actions.ts
'use server'

import { createAdminClient, getProfileByAdmin } from '@/lib/supabase/admin'
import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { z } from 'zod'

// Schema de Validação
const StoreProfileSchema = z.object({
    id: z.coerce.number(),
    name: z.string().min(2, "Nome Fantasia é obrigatório"),
    razao_social: z.string().optional().nullable(),
    cnpj: z.string().optional().nullable(),
    inscricao_estadual: z.string().optional().nullable(),
    
    whatsapp: z.string().optional().nullable(),
    phone: z.string().optional().nullable(),
    email: z.string().email().optional().or(z.literal('')).nullable(),
    website: z.string().optional().nullable(),
    
    cep: z.string().optional().nullable(),
    street: z.string().optional().nullable(),
    number: z.string().optional().nullable(),
    neighborhood: z.string().optional().nullable(),
    city: z.string().optional().nullable(),
    state: z.string().length(2).optional().or(z.literal('')).nullable(),
})

export type StoreActionResult = {
    success: boolean
    message: string
}

export async function getStoreProfile(storeId: number) {
    const supabaseAdmin = createAdminClient()
    try {
        // CORREÇÃO: Cast 'as any' para ler colunas novas
        const { data } = await (supabaseAdmin.from('stores') as any)
            .select('*')
            .eq('id', storeId)
            .single()
        return data
    } catch (e) {
        return null
    }
}

export async function updateStoreProfile(prevState: any, formData: FormData): Promise<StoreActionResult> {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user) return { success: false, message: 'Sem permissão.' }
    const profile = await getProfileByAdmin(user.id) as any
    
    // Segurança: Apenas Admin ou Gerente da própria loja
    const storeId = parseInt(formData.get('id') as string)
    if (profile.role !== 'admin' && profile.store_id !== storeId) {
        return { success: false, message: 'Acesso negado.' }
    }

    const rawData = {
        id: formData.get('id'),
        name: formData.get('name'),
        razao_social: formData.get('razao_social'),
        cnpj: formData.get('cnpj'),
        inscricao_estadual: formData.get('inscricao_estadual'),
        whatsapp: formData.get('whatsapp'), // <--- CAMPO NOVO
        phone: formData.get('phone'),
        email: formData.get('email'),
        website: formData.get('website'),
        cep: formData.get('cep'),
        street: formData.get('street'),
        number: formData.get('number'),
        neighborhood: formData.get('neighborhood'),
        city: formData.get('city'),
        state: formData.get('state'),
    }

    const validated = StoreProfileSchema.safeParse(rawData)
    
    if (!validated.success) {
        return { success: false, message: 'Dados inválidos. Verifique os campos.' }
    }

    const { id, ...updateData } = validated.data
    const supabaseAdmin = createAdminClient()

    try {
        // CORREÇÃO: Cast 'as any' para update nas colunas novas
        await (supabaseAdmin.from('stores') as any)
            .update(updateData)
            .eq('id', id)

        revalidatePath(`/dashboard/loja/${id}/config`)
        return { success: true, message: 'Dados da loja atualizados!' }
    } catch (e: any) {
        return { success: false, message: e.message }
    }
}

==================================================
ARQUIVO: .\src\lib\actions\vendas.actions.ts
==================================================
'use server'

import { createClient } from '@/lib/supabase/server'
import { Database } from '@/lib/database.types'
import { revalidatePath } from 'next/cache'
import { z } from 'zod'
import { createAdminClient, getProfileByAdmin } from '@/lib/supabase/admin'
import { useCredit } from './wallet.actions'
import { calcularERegistrarComissao, cancelarComissao } from './commission.actions'

// ================================================================
// --- TIPOS GLOBAIS ---
// ================================================================

type Customer = Database['public']['Tables']['customers']['Row']
type Dependente = Database['public']['Tables']['dependentes']['Row']
type Venda = Database['public']['Tables']['vendas']['Row']
type VendaItem = Database['public']['Tables']['venda_itens']['Row']
type ServiceOrder = Database['public']['Tables']['service_orders']['Row']
type Oftalmologista = Database['public']['Tables']['oftalmologistas']['Row']
type Product = Database['public']['Tables']['products']['Row']
type Pagamento = Database['public']['Tables']['pagamentos']['Row']
type Financiamento = Database['public']['Tables']['financiamento_loja']['Row']
type FinanciamentoParcela = Database['public']['Tables']['financiamento_parcelas']['Row']
type Employee = Database['public']['Tables']['employees']['Row']

type ServiceOrderWithLinks = ServiceOrder & {
  links?: { venda_item_id: number; uso_na_os: string }[]
}
export type CreateFinanciamentoResult = {
  success: boolean
  message: string
  errors?: Record<string, string[]>
}

export type OSPageData = {
  customer: Customer | null
  venda: Venda | null
  dependentes: Dependente[]
  oftalmologistas: Oftalmologista[]
  employees: Employee[]
  vendaItens: VendaItem[]
  existingOrders: ServiceOrderWithLinks[]
}

export type GetOSPageDataResult = {
  success: boolean
  message?: string
  data?: OSPageData
}

export type SaveSOResult = {
  success: boolean
  message: string
  data?: ServiceOrder
  errors?: Record<string, string[]>
  timestamp?: number
}

// ==============================================================================
// SCHEMAS E TIPOS
// ==============================================================================

export type VendaPageData = {
  venda: Venda
  customer: Customer | null
  employee: Employee | null
  vendaItens: VendaItem[]
  serviceOrders: ServiceOrder[]
  pagamentos: Pagamento[]
  financiamento: (Financiamento & { financiamento_parcelas: FinanciamentoParcela[] }) | null
  // CORREÇÃO: Agora são listas de Product
  lentes: Product[]
  armacoes: Product[]
  tratamentos: Product[]
}

export type GetVendaPageDataResult = {
  success: boolean
  message?: string
  data?: VendaPageData
}

// ================================================================
// 1. ACTION: BUSCAR DADOS DA PÁGINA DE OS
// ================================================================
export async function getOSPageData(
  vendaId: number,
  storeId: number,
  customerId: number
): Promise<GetOSPageDataResult> {
  const supabase = createAdminClient()

  try {
    const [
      customerRes,
      vendaRes,
      dependentesRes,
      oftalmosRes,
      employeesRes,
      itensRes,
      osRes,
    ] = await Promise.all([
      supabase.from('customers').select('*').eq('id', customerId).single(),
      supabase.from('vendas').select('*').eq('id', vendaId).single(),
      supabase.from('dependentes').select('*').eq('customer_id', customerId).order('full_name'),
      supabase.from('oftalmologistas').select('*').eq('store_id', storeId).order('nome_completo'),
      supabase.from('employees').select('*').eq('store_id', storeId).eq('is_active', true).order('full_name'),
      supabase.from('venda_itens').select('*').eq('venda_id', vendaId).order('id'),
      supabase.from('service_orders')
        .select('*, links:venda_itens_os_links(venda_item_id, uso_na_os)')
        .eq('venda_id', vendaId)
        .order('created_at'),
    ])

    if (customerRes.error) throw new Error(`Cliente: ${customerRes.error.message}`)
    
    const data: OSPageData = {
      customer: customerRes.data,
      venda: vendaRes.data,
      dependentes: dependentesRes.data || [],
      oftalmologistas: oftalmosRes.data || [],
      employees: employeesRes.data || [],
      vendaItens: itensRes.data || [],
      existingOrders: osRes.data || [],
    }

    return { success: true, data }
  } catch (error: any) {
    return { success: false, message: error.message }
  }
}

// ================================================================
// 2. ACTION: SALVAR OS (CORRIGIDA E COMPLETA)
// ================================================================
const ServiceOrderSchema = z.object({
  id: z.coerce.number().optional(),
  store_id: z.coerce.number(),
  venda_id: z.coerce.number(),
  customer_id: z.coerce.number(),
  dependente_id: z.coerce.number().optional().nullable(),
  oftalmologista_id: z.coerce.number().optional().nullable(),
  // Receita
  receita_longe_od_esferico: z.string().nullable(),
  receita_longe_od_cilindrico: z.string().nullable(),
  receita_longe_od_eixo: z.string().nullable(),
  receita_longe_oe_esferico: z.string().nullable(),
  receita_longe_oe_cilindrico: z.string().nullable(),
  receita_longe_oe_eixo: z.string().nullable(),
  receita_perto_od_esferico: z.string().nullable(),
  receita_perto_od_cilindrico: z.string().nullable(),
  receita_perto_od_eixo: z.string().nullable(),
  receita_perto_oe_esferico: z.string().nullable(),
  receita_perto_oe_cilindrico: z.string().nullable(),
  receita_perto_oe_eixo: z.string().nullable(),
  receita_adicao: z.string().nullable(),
  // Medidas
  medida_horizontal: z.string().nullable(),
  medida_vertical: z.string().nullable(),
  medida_diagonal: z.string().nullable(),
  medida_ponte: z.string().nullable(),
  medida_dnp_od: z.string().nullable(),
  medida_dnp_oe: z.string().nullable(),
  medida_altura_od: z.string().nullable(),
  medida_altura_oe: z.string().nullable(),
  medida_diametro: z.string().nullable(),
  // Lab
  lab_nome: z.string().nullable(),
  lab_pedido_por_id: z.coerce.number().optional().nullable(),
  dt_pedido_em: z.string().nullable(),
  dt_lente_chegou: z.string().nullable(),
  dt_montado_em: z.string().nullable(),
  dt_entregue_em: z.string().nullable(),
  dt_prometido_para: z.string().nullable(),
  obs_os: z.string().nullable(),
  protocolo_fisico: z.string().optional().nullable(),
})

const ItemLinkSchema = z.object({
  item_id: z.coerce.number(),
  uso: z.enum(['lente_od', 'lente_oe', 'armacao']),
})

export async function saveServiceOrder(
  prevState: SaveSOResult,
  formData: FormData
): Promise<SaveSOResult> {
  const supabaseAdmin = createAdminClient()
  const { data: { user } } = await createClient().auth.getUser()
  
  if (!user) return { success: false, message: 'Usuário não autenticado.', timestamp: Date.now() }
  const { data: profile } = await supabaseAdmin.from('profiles').select('tenant_id, store_id').eq('id', user.id).single()
  if (!profile) return { success: false, message: 'Perfil não encontrado.', timestamp: Date.now() }

  const { tenant_id } = profile // Nota: Não usamos profile.store_id aqui para evitar o bug
  const nullIfEmpty = (val: unknown) => (val === '' ? null : val)
  const parseDate = (val: unknown) => (val && val !== '') ? new Date(val as string).toISOString() : null

  const validated = ServiceOrderSchema.safeParse({
    id: nullIfEmpty(formData.get('id')),
    
    // ✅ CORREÇÃO 1: Pegamos o store_id do FORMULÁRIO (Contexto Real), não do Perfil
    store_id: formData.get('store_id'), 

    venda_id: formData.get('venda_id'),
    customer_id: formData.get('customer_id'),
    dependente_id: nullIfEmpty(formData.get('dependente_id')),
    oftalmologista_id: nullIfEmpty(formData.get('oftalmologista_id')),
    receita_longe_od_esferico: nullIfEmpty(formData.get('receita_longe_od_esferico')),
    receita_longe_od_cilindrico: nullIfEmpty(formData.get('receita_longe_od_cilindrico')),
    receita_longe_od_eixo: nullIfEmpty(formData.get('receita_longe_od_eixo')),
    receita_longe_oe_esferico: nullIfEmpty(formData.get('receita_longe_oe_esferico')),
    receita_longe_oe_cilindrico: nullIfEmpty(formData.get('receita_longe_oe_cilindrico')),
    receita_longe_oe_eixo: nullIfEmpty(formData.get('receita_longe_oe_eixo')),
    receita_perto_od_esferico: nullIfEmpty(formData.get('receita_perto_od_esferico')),
    receita_perto_od_cilindrico: nullIfEmpty(formData.get('receita_perto_od_cilindrico')),
    receita_perto_od_eixo: nullIfEmpty(formData.get('receita_perto_od_eixo')),
    receita_perto_oe_esferico: nullIfEmpty(formData.get('receita_perto_oe_esferico')),
    receita_perto_oe_cilindrico: nullIfEmpty(formData.get('receita_perto_oe_cilindrico')),
    receita_perto_oe_eixo: nullIfEmpty(formData.get('receita_perto_oe_eixo')),
    receita_adicao: nullIfEmpty(formData.get('receita_adicao')),
    medida_horizontal: nullIfEmpty(formData.get('medida_horizontal')),
    medida_vertical: nullIfEmpty(formData.get('medida_vertical')),
    medida_diagonal: nullIfEmpty(formData.get('medida_diagonal')),
    medida_ponte: nullIfEmpty(formData.get('medida_ponte')),
    medida_dnp_od: nullIfEmpty(formData.get('medida_dnp_od')),
    medida_dnp_oe: nullIfEmpty(formData.get('medida_dnp_oe')),
    medida_altura_od: nullIfEmpty(formData.get('medida_altura_od')),
    medida_altura_oe: nullIfEmpty(formData.get('medida_altura_oe')),
    medida_diametro: nullIfEmpty(formData.get('medida_diametro')),
    lab_nome: nullIfEmpty(formData.get('lab_nome')),
    lab_pedido_por_id: nullIfEmpty(formData.get('lab_pedido_por_id')),
    dt_pedido_em: parseDate(formData.get('dt_pedido_em')),
    dt_lente_chegou: parseDate(formData.get('dt_lente_chegou')),
    dt_montado_em: parseDate(formData.get('dt_montado_em')),
    dt_entregue_em: parseDate(formData.get('dt_entregue_em')),
    dt_prometido_para: parseDate(formData.get('dt_prometido_para')),
    obs_os: nullIfEmpty(formData.get('obs_os')),
    protocolo_fisico: nullIfEmpty(formData.get('protocolo_fisico')),
  })

  if (!validated.success) {
    return { success: false, message: 'Erro de validação.', errors: validated.error.flatten().fieldErrors, timestamp: Date.now() }
  }

  const { id, ...osData } = validated.data

  let itemLinks: z.infer<typeof ItemLinkSchema>[] = []
  try {
    const json = formData.get('item_links_json') as string
    if (json) itemLinks = JSON.parse(json)
  } catch (e) {
    return { success: false, message: 'Erro nos vínculos de itens.', timestamp: Date.now() }
  }

  try {
    const payload: any = { ...osData, tenant_id: (profile as any).tenant_id }
    let savedId: number

    if (id) {
      if (!payload.protocolo_fisico) payload.protocolo_fisico = id.toString();
      const { error } = await (supabaseAdmin.from('service_orders') as any).update(payload).eq('id', id).select().single()
      if (error) throw error
      savedId = id
    } else {
      const { data, error } = await (supabaseAdmin.from('service_orders') as any).insert(payload).select('id').single()
      if (error) throw error
      savedId = data.id
      if (!payload.protocolo_fisico) await (supabaseAdmin.from('service_orders') as any).update({ protocolo_fisico: savedId.toString() }).eq('id', savedId)
    }

    // Limpa vínculos antigos
    await supabaseAdmin.from('venda_itens_os_links').delete().eq('service_order_id', savedId)

    // Insere novos vínculos
    if (itemLinks.length > 0) {
      const linksToInsert = itemLinks.map((link) => ({
        tenant_id: tenant_id, 
        store_id: osData.store_id, // ✅ CORREÇÃO 2: Usa o store_id validado (correto), não o do profile
        service_order_id: savedId, 
        venda_item_id: link.item_id, 
        uso_na_os: link.uso
      }))
      
      const { error: linkError } = await (supabaseAdmin.from('venda_itens_os_links') as any).insert(linksToInsert as any)
      if (linkError) {
          console.error("Erro ao salvar links:", linkError)
      }
    }

    revalidatePath(`/dashboard/loja/${osData.store_id}/vendas/${osData.venda_id}/os`)
    revalidatePath(`/dashboard/loja/${osData.store_id}/vendas/${osData.venda_id}`) 
    
    const { data: finalOS } = await supabaseAdmin
      .from('service_orders')
      .select('*, links:venda_itens_os_links(venda_item_id, uso_na_os)')
      .eq('id', savedId)
      .single()

    return { success: true, message: 'OS salva com sucesso!', data: finalOS as any, timestamp: Date.now() }
  } catch (error: any) {
    return { success: false, message: `Erro no banco: ${error.message}`, timestamp: Date.now() }
  }
}

// ================================================================
// 3. ACTION: DELETAR OS
// ================================================================
export async function deleteServiceOrder(id: number, storeId: number, vendaId: number): Promise<SaveSOResult> {
  const supabaseAdmin = createAdminClient()
  try {
    const { error } = await supabaseAdmin.from('service_orders').delete().eq('id', id)
    if (error) throw error
    
    revalidatePath(`/dashboard/loja/${storeId}/vendas/${vendaId}/os`)
    revalidatePath(`/dashboard/loja/${storeId}/vendas/${vendaId}`)

    return { success: true, message: 'OS excluída.', timestamp: Date.now() }
  } catch (e: any) {
    return { success: false, message: e.message, timestamp: Date.now() }
  }
}

// ================================================================
// 4. ACTIONS: BUSCAR CLIENTES (BLOCO COMPLETO)
// ================================================================

export type CustomerSearchResult = Pick<Customer, 'id' | 'full_name' | 'cpf' | 'fone_movel' | 'obs_debito'>

export type SearchCustomersResult = {
  success: boolean
  message?: string
  data?: CustomerSearchResult[]
}

export type GetCustomerResult = {
  success: boolean
  message?: string
  data?: Customer
}

// 1. Busca Padrão (Lista Inicial)
export async function fetchDefaultCustomers(storeId: number): Promise<SearchCustomersResult> {
  const supabaseAdmin = createAdminClient()
  const { data, error } = await supabaseAdmin
    .from('customers')
    .select('id, full_name, cpf, fone_movel, obs_debito') 
    .eq('store_id', storeId)
    .order('created_at', { ascending: false })
    .limit(20)

  if (error) {
    return { success: false, message: error.message }
  }
  return { success: true, data: data as any } 
}

// 2. Busca por Nome ou CPF (A que corrigimos antes)
export async function searchCustomersByName(
  query: string,
  storeId: number
): Promise<SearchCustomersResult> {
  const supabaseAdmin = createAdminClient()
  const termo = query.trim()

  const { data, error } = await supabaseAdmin
    .from('customers')
    .select('id, full_name, cpf, fone_movel, obs_debito')
    .eq('store_id', storeId)
    .or(`full_name.ilike.%${termo}%,cpf.ilike.%${termo}%`)
    .limit(20)

  if (error) {
    return { success: false, message: error.message }
  }
  return { success: true, data }
}

// 3. Busca por ID (Detalhes)
export async function getCustomerById(
  customerId: number
): Promise<GetCustomerResult> {
  const supabaseAdmin = createAdminClient()
  const { data, error } = await supabaseAdmin
    .from('customers')
    .select('*')
    .eq('id', customerId)
    .single()

  if (error) {
    return { success: false, message: error.message }
  }
  return { success: true, data }
}

// ================================================================
// 5. ACTION: CRIAR NOVA VENDA (LIMPA E CORRIGIDA)
// ================================================================

export async function createNewVenda(
  customerId: number,
  employeeId?: number | null
): Promise<CreateVendaResult> {
  const supabase = createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) { return { success: false, message: 'Usuário não autenticado.' } }
  
const profile: any = await getProfileByAdmin(user.id)
 if (!profile || !profile.tenant_id || !profile.store_id) {
  return { success: false, message: 'Perfil do usuário não encontrado.' }
}



  const vendaData = {
    tenant_id: profile.tenant_id,
    store_id: profile.store_id,
    customer_id: customerId,
    employee_id: (employeeId ?? null) as number | null,
    created_by_user_id: user.id,
    status: 'Em Aberto',
    valor_total: 0, 
    valor_desconto: 0, 
    valor_final: 0,
  }

  const supabaseAdmin = createAdminClient();

  try {
    const { data, error } = await (supabaseAdmin.from('vendas') as any)
        .insert(vendaData)
        .select()
        .single()
    
    if (error) throw error
    return { success: true, message: 'Venda iniciada.', data }
  } 
  catch (error: any) {
    return { success: false, message: `Erro ao criar venda: ${error.message}` }
  }
}

// ================================================================
// 6. ACTION: BUSCAR DADOS DA PÁGINA DE VENDA (ATUALIZADO PARA UNIFICAÇÃO)
// ================================================================
export async function getVendaPageData(
  vendaId: number,
  storeId: number
): Promise<GetVendaPageDataResult> {
  const supabaseAdmin = createAdminClient()

  try {
    const { data: venda, error: vendaError } = await supabaseAdmin
      .from('vendas')
      .select('*')
      .eq('id', vendaId)
      .eq('store_id', storeId)
      .single()

    if (vendaError || !venda) {
      return { success: false, message: `Venda não encontrada: ${vendaError?.message}`, }
    }

    const { customer_id, employee_id } = venda

    const [
      customerRes,
      employeeRes, 
      itensRes,
      osRes,
      pagamentosRes,
      financiamentoRes,
      // BUSCA AGORA NA TABELA PRODUCTS COM FILTRO
      lentesRes,
      armacoesRes,
      tratamentosRes,
    ] = await Promise.all([
      supabaseAdmin.from('customers').select('*').eq('id', customer_id).single(),
      employee_id ? supabaseAdmin.from('employees').select('*').eq('id', employee_id).single() : Promise.resolve({ data: null }),
      supabaseAdmin.from('venda_itens').select('*').eq('venda_id', vendaId).order('id'),
      supabaseAdmin.from('service_orders').select('*').eq('venda_id', vendaId),
      supabaseAdmin.from('pagamentos').select('*').eq('venda_id', vendaId).order('data_pagamento'),
      supabaseAdmin.from('financiamento_loja').select('*, financiamento_parcelas(*)').eq('venda_id', vendaId).maybeSingle(),
      
      // Consultas unificadas
      supabaseAdmin.from('products').select('*').eq('store_id', storeId).eq('tipo_produto', 'Lente'),
      supabaseAdmin.from('products').select('*').eq('store_id', storeId).eq('tipo_produto', 'Armacao'),
      supabaseAdmin.from('products').select('*').eq('store_id', storeId).eq('tipo_produto', 'Tratamento'),
    ])
    
    const data: VendaPageData = {
      venda,
      customer: customerRes.data,
      employee: employeeRes.data,
      vendaItens: itensRes.data || [],
      serviceOrders: osRes.data || [],
      pagamentos: pagamentosRes.data || [],
      financiamento: financiamentoRes.data as any, 
      lentes: lentesRes.data || [],
      armacoes: armacoesRes.data || [],
      tratamentos: tratamentosRes.data || [],
    }

    return { success: true, data }
  } catch (error: any) {
    console.error("ERRO FATAL NA BUSCA DE VENDA:", error);
    return { success: false, message: 'Falha na busca interna de dados.' }
  }
}

// ================================================================
// 7. ACTION: ADICIONAR ITEM À VENDA (CORRIGIDO COM 'AS ANY')
// ================================================================
const VendaItemSchema = z.object({
  venda_id: z.coerce.number(),
  item_tipo: z.enum(['Lente', 'Armacao', 'Tratamento', 'Servico', 'Outro']),
  descricao: z.string().min(1, { message: 'Descrição é obrigatória.' }),
  lente_id: z.coerce.number().optional().nullable(),
  armacao_id: z.coerce.number().optional().nullable(),
  tratamento_id: z.coerce.number().optional().nullable(),
  quantidade: z.coerce.number().min(1),
  valor_unitario: z.coerce.number(),
})

export type SaveVendaItemResult = {
  success: boolean
  message: string
  data?: VendaItem
  errors?: Record<string, string[]>
  timestamp?: number 
}

export async function addVendaItem(
  prevState: SaveVendaItemResult,
  formData: FormData
): Promise<SaveVendaItemResult> {
  const supabase = createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return { success: false, message: 'Usuário não autenticado.' }
  
  const profile = await getProfileByAdmin(user.id)
  if (!profile) return { success: false, message: 'Perfil não encontrado.' }

  const nullIfEmpty = (val: unknown) => (val === '' ? null : val)
  
  const validatedFields = VendaItemSchema.safeParse({
    venda_id: formData.get('venda_id'),
    item_tipo: formData.get('item_tipo'),
    descricao: formData.get('descricao'),
    lente_id: nullIfEmpty(formData.get('lente_id')),
    armacao_id: nullIfEmpty(formData.get('armacao_id')),
    tratamento_id: nullIfEmpty(formData.get('tratamento_id')),
    quantidade: formData.get('quantidade'),
    valor_unitario: formData.get('valor_unitario'),
  })

  if (!validatedFields.success) {
    return {
      success: false,
      message: 'Erro de validação.',
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  const data = validatedFields.data
  const valor_total_item = data.quantidade * data.valor_unitario

  // Definimos o ID do produto unificado
  const productId = data.lente_id || data.armacao_id || data.tratamento_id;

  // Montamos o objeto (sem tipagem estrita para evitar o erro 'never')
const itemToInsert = {
    venda_id: data.venda_id,
    product_id: productId, 
    variant_id: null,      
    item_tipo: data.item_tipo,
    descricao: data.descricao,
    quantidade: data.quantidade,
    valor_unitario: data.valor_unitario,
    valor_total_item: valor_total_item,
    tenant_id: (profile as any).tenant_id, // Forçamos aqui
    store_id: (profile as any).store_id,   // CORREÇÃO: Forçamos aqui também
  }

const supabaseAdmin = createAdminClient();

  try {
    // CORREÇÃO 1: Usamos (as any) na chamada da tabela
    const { data: newItem, error: itemError } = await (supabaseAdmin.from('venda_itens') as any)
      .insert(itemToInsert)
      .select()
      .single()

    if (itemError) throw itemError
    if (!newItem) throw new Error('Falha ao inserir item.')

    // CORREÇÃO 2: Cast no supabaseAdmin para o RPC funcionar sem reclamar
    const { error: rpcError } = await (supabaseAdmin as any).rpc('update_venda_financeiro', {
      p_venda_id: data.venda_id,
    })
    
    if (rpcError) throw new Error(`Erro ao recalcular total: ${rpcError.message}`)

    // CORREÇÃO 3: Cast no profile para o revalidatePath
    revalidatePath(`/dashboard/loja/${(profile as any).store_id}/vendas`)
    revalidatePath(`/dashboard/loja/${(profile as any).store_id}/vendas/${data.venda_id}`)
    
    return { success: true, message: 'Item adicionado!', data: newItem as any }
  } catch (error: any) {
    return { success: false, message: error.message }
  }
}

// ================================================================
// 8. ACTION: DELETAR ITEM DA VENDA
// ================================================================
export type DeleteVendaItemResult = {
  success: boolean
  message: string
}

export async function deleteVendaItem(
  itemId: number,
  vendaId: number,
  storeId: number
): Promise<DeleteVendaItemResult> {
  const supabaseAdmin = createAdminClient()
  
  try {
    const { error: deleteError } = await supabaseAdmin
      .from('venda_itens')
      .delete()
      .eq('id', itemId)

    if (deleteError) throw deleteError

    // CORREÇÃO: Usamos (as any) para o RPC funcionar sem erro de tipagem
    const { error: rpcError } = await (supabaseAdmin as any).rpc('update_venda_financeiro', {
      p_venda_id: vendaId,
    })
    
    if (rpcError) throw new Error(`Erro ao recalcular total: ${rpcError.message}`)
    
    revalidatePath(`/dashboard/loja/${storeId}/vendas`)
    revalidatePath(`/dashboard/loja/${storeId}/vendas/${vendaId}`)
    
    return { success: true, message: 'Item removido.' }
  } catch (error: any) {
    return { success: false, message: error.message }
  }
}

// ================================================================
// 9. ACTION: ADICIONAR PAGAMENTO (CORRIGIDA: ARREDONDAMENTO)
// ================================================================

// MANTENHA O SCHEMA AQUI FORA (Se já tiver no arquivo, não precisa duplicar, mas certifique-se que ele existe)
const PagamentoSchema = z.object({
  venda_id: z.coerce.number(),
  customer_id: z.coerce.number(),
  employee_id: z.coerce.number(),
  forma_pagamento: z.string().min(1, { message: 'Forma de pagamento é obrigatória.' }),
  valor_pago: z.coerce.number().min(0.01, { message: 'Valor deve ser positivo.' }),
  parcelas: z.coerce.number().min(1),
  data_pagamento: z.string(),
  obs: z.string().optional().nullable(),
})

export type SavePagamentoResult = {
  success: boolean
  message: string
  data?: Pagamento
  errors?: Record<string, string[]>
  timestamp?: number 
}

export async function addPagamento(
  prevState: SavePagamentoResult,
  formData: FormData
): Promise<SavePagamentoResult> {
  const supabase = createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return { success: false, message: 'Usuário não autenticado.' }
  
  const profile = await getProfileByAdmin(user.id)
  if (!profile) return { success: false, message: 'Perfil não encontrado.' }
  
  const { tenant_id, store_id } = profile

  const valorRaw = formData.get('valor_pago') as string;
  const valorLimpo = valorRaw 
    ? parseFloat(valorRaw.replace(/\./g, '').replace(',', '.')) 
    : 0;

  const validatedFields = PagamentoSchema.safeParse({
    venda_id: formData.get('venda_id'),
    customer_id: formData.get('customer_id'),
    employee_id: formData.get('employee_id'),
    forma_pagamento: formData.get('forma_pagamento'),
    valor_pago: valorLimpo,
    parcelas: formData.get('parcelas'),
    data_pagamento: formData.get('data_pagamento'),
    obs: formData.get('obs'),
  })

  if (!validatedFields.success) {
    return {
      success: false,
      message: 'Erro de validação. Verifique o valor e campos.',
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  const { venda_id, ...pagamentoData } = validatedFields.data

  const supabaseAdmin = createAdminClient();

  // --- LÓGICA DE CRÉDITO (Carteira do Cliente) ---
  if (pagamentoData.forma_pagamento === 'Crédito em Loja') {
      const fdWallet = new FormData()
      fdWallet.append('store_id', String(store_id))
      fdWallet.append('customer_id', String(pagamentoData.customer_id))
      fdWallet.append('amount', String(pagamentoData.valor_pago))
      fdWallet.append('description', `Pagamento na Venda #${venda_id}`)
      fdWallet.append('employee_id', String(pagamentoData.employee_id))
      fdWallet.append('related_venda_id', String(venda_id))

      const resWallet = await useCredit(fdWallet)
      if (!resWallet.success) {
          return { success: false, message: resWallet.message } 
      }
  }
  // -----------------------------------------------

  const pagToInsert = {
    ...pagamentoData,
    venda_id,
    tenant_id,
    store_id,
    created_by_user_id: user.id,
  }

  try {
    // 1. Inserir na tabela de pagamentos (Isso baixa o saldo da venda)
    const { data: newPagamento, error: pagError } = await (supabaseAdmin.from('pagamentos') as any)
      .insert(pagToInsert)
      .select()
      .single()

    if (pagError) throw pagError
    if (!newPagamento) throw new Error('Falha ao registrar pagamento.')

    // 2. NOVO: Se for Cartão Crédito ou Cheque-Pré, lançar no Contas a Receber
    const forma = pagamentoData.forma_pagamento;
    if (forma === 'Cartão Crédito' || forma === 'Cheque-Pré') {
        const qtdParcelas = pagamentoData.parcelas;
        const valorTotal = pagamentoData.valor_pago;
        
        // --- CÁLCULO DE CENTAVOS (CORREÇÃO) ---
        const valorParcelaBase = Math.floor((valorTotal / qtdParcelas) * 100) / 100;
        const diferenca = parseFloat((valorTotal - (valorParcelaBase * qtdParcelas)).toFixed(2));
        
        const receivables = [];
        const dataBase = new Date(pagamentoData.data_pagamento);

        for (let i = 0; i < qtdParcelas; i++) {
            const vencimento = new Date(dataBase);
            vencimento.setDate(vencimento.getDate() + (i * 30));
            
            // Adiciona a diferença na primeira parcela para fechar a conta exata
            let valorDestaParcela = valorParcelaBase;
            if (i === 0) {
                valorDestaParcela += diferenca;
            }
            
            receivables.push({
                tenant_id: tenant_id,
                store_id: store_id,
                description: `Venda #${venda_id} - ${forma} (${i + 1}/${qtdParcelas})`,
                amount: parseFloat(valorDestaParcela.toFixed(2)),
                due_date: vencimento.toISOString().split('T')[0],
                status: 'Pendente',
                type: forma,
                origin_payment_id: newPagamento.id
            });
        }

        await (supabaseAdmin.from('accounts_receivable') as any).insert(receivables);
    }

    // 3. Atualiza saldo da venda
    const { error: rpcError } = await (supabaseAdmin as any).rpc('update_venda_financeiro', {
      p_venda_id: venda_id,
    })
    
    if (rpcError) throw new Error(`Erro ao recalcular total: ${rpcError.message}`)

    revalidatePath(`/dashboard/loja/${store_id}/vendas`)
    revalidatePath(`/dashboard/loja/${store_id}/vendas/${venda_id}`)
    
    return { success: true, message: 'Pagamento registrado!', data: newPagamento as any, timestamp: Date.now() }
  } catch (error: any) {
    return { success: false, message: error.message }
  }
}

// ================================================================
// 10. ACTION: DELETAR PAGAMENTO (CORRIGIDA: LIMPA RECEBÍVEIS)
// ================================================================
export type DeletePagamentoResult = {
  success: boolean
  message: string
}

export async function deletePagamento(
  pagamentoId: number,
  vendaId: number,
  storeId: number
): Promise<DeletePagamentoResult> {
  // CORREÇÃO: Usamos AdminClient para evitar Loop de RLS
  const supabaseAdmin = createAdminClient()

  try {
    // 1. NOVO: Antes de apagar o pagamento, apaga os recebíveis (Cartão/Cheque) vinculados a ele
    const { error: deleteReceivablesError } = await supabaseAdmin
        .from('accounts_receivable')
        .delete()
        .eq('origin_payment_id', pagamentoId);

    if (deleteReceivablesError) {
        console.error("Erro ao limpar recebíveis:", deleteReceivablesError);
    }

    // 2. Apaga o pagamento principal
    const { error: deleteError } = await supabaseAdmin
      .from('pagamentos')
      .delete()
      .eq('id', pagamentoId)

    if (deleteError) throw deleteError

    // 3. Recalcula o saldo da venda (RPC)
    const { error: rpcError } = await (supabaseAdmin as any).rpc('update_venda_financeiro', {
      p_venda_id: vendaId,
    })
    
    if (rpcError) throw new Error(`Erro ao recalcular total: ${rpcError.message}`)

    revalidatePath(`/dashboard/loja/${storeId}/vendas`)
    revalidatePath(`/dashboard/loja/${storeId}/vendas/${vendaId}`)
    
    return { success: true, message: 'Pagamento removido.' }
  } catch (error: any) {
    return { success: false, message: error.message }
  }
}

// ================================================================
// 11. ACTION: ATUALIZAR STATUS DA VENDA (COM TIMESTAMP E AUDITORIA)
// ================================================================
export type CreateVendaResult = {
  success: boolean
  message?: string
  data?: Venda 
  timestamp?: number
}

export async function updateVendaStatus(
  vendaId: number,
  storeId: number,
  newStatus: 'Fechada' | 'Cancelada' | 'Em Aberto',
  acting_employee_id?: number // NOVO: Quem realizou a ação
): Promise<CreateVendaResult> { 
  
  const supabaseAdmin = createAdminClient()

  try {
    const updatePayload: any = { status: newStatus };

    if (newStatus === 'Em Aberto') {
      // REABERTURA: 
      // 1. Remove o vínculo com financiamento (se houver, para permitir recriar)
      updatePayload.financiamento_id = null;
      
      // 2. IMPORTANTE: Estorna a comissão gerada anteriormente para evitar duplicidade
      await cancelarComissao(vendaId)
    }

    const { data, error } = await (supabaseAdmin.from('vendas') as any)
      .update(updatePayload) 
      .eq('id', vendaId)
      .select()
      .single()

    if (error) throw error

    // --- GATILHO DE FECHAMENTO ---
    if (newStatus === 'Fechada') {
       // Calcula comissão nova
       await calcularERegistrarComissao(vendaId)
       
       // Opcional: Aqui poderíamos salvar um log de "Quem fechou" se houvesse tabela de logs
       // Por enquanto, confiamos no PIN validado no frontend para a sessão
    } else if (newStatus === 'Cancelada') {
        await cancelarComissao(vendaId)
    }
    // ---------------------------

    revalidatePath(`/dashboard/loja/${storeId}/vendas`)
    revalidatePath(`/dashboard/loja/${storeId}/vendas/${vendaId}`)
    
    return { 
        success: true, 
        message: `Venda ${newStatus}!`, 
        data, 
        timestamp: Date.now() 
    }

  } catch (error: any) {
    return { success: false, message: error.message, timestamp: Date.now() }
  }
}

// ================================================================
// 12. ACTION: ATUALIZAR DESCONTO DA VENDA
// ================================================================
const DescontoSchema = z.object({
  venda_id: z.coerce.number(),
  store_id: z.coerce.number(),
  valor_desconto: z.coerce.number().min(0, 'Desconto não pode ser negativo.'),
})

export type UpdateDescontoResult = {
  success: boolean
  message: string
  errors?: Record<string, string[]>
}

export async function updateVendaDesconto(
  prevState: UpdateDescontoResult,
  formData: FormData
): Promise<UpdateDescontoResult> {
  const supabase = createClient()

  const validatedFields = DescontoSchema.safeParse({
    venda_id: formData.get('venda_id'),
    store_id: formData.get('store_id'),
    valor_desconto: formData.get('valor_desconto'),
  })

  if (!validatedFields.success) {
    return {
      success: false,
      message: 'Erro de validação.',
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  const { venda_id, store_id, valor_desconto } = validatedFields.data

  try {
    const { error: updateError } = await supabase
      .from('vendas')
      .update({ valor_desconto: valor_desconto })
      .eq('id', venda_id)

    if (updateError) throw updateError

    const { error: rpcError } = await supabase.rpc('update_venda_financeiro', {
      p_venda_id: venda_id,
    })

    if (rpcError)
      throw new Error(`Erro ao recalcular totais: ${rpcError.message}`)

    revalidatePath(`/dashboard/loja/${store_id}/vendas`)
    revalidatePath(`/dashboard/loja/${store_id}/vendas/${venda_id}`)
    
    return { success: true, message: 'Desconto aplicado!' }
  } catch (error: any) {
    return { success: false, message: error.message }
  }
}

// ==============================================================================
// 13. ACTION: CRIAR FINANCIAMENTO DE LOJA (FINAL: SEGURA + ADMIN MODE)
// ==============================================================================
export async function saveFinanciamentoLoja(...args: any[]) {
  // 1. Normalização de dados (Suporta chamada via Form ou Objeto JS)
  let data: any = args[1] || args[0]; 
  if (data instanceof FormData) data = Object.fromEntries(data);

  const { venda_id, valor_total, qtd_parcelas, data_primeiro_vencimento, customer_id, employee_id, obs } = data || {};

  if (!venda_id || !qtd_parcelas) {
      return { success: false, message: 'Erro: Dados incompletos.' };
  }

  // 2. Autenticação
  const supabaseAuth = createClient();
  const { data: { user } } = await supabaseAuth.auth.getUser();
  if (!user) return { success: false, message: 'Sessão expirada.' };

  // 3. Verificação de Perfil e Segurança
  const profile = await getProfileByAdmin(user.id) as any;
  if (!profile) return { success: false, message: 'Perfil não encontrado.' };

  // 4. Inicia Modo Admin (Para evitar Loop RLS)
  const supabaseAdmin = createAdminClient();

  // 5. Busca dados da Venda para validar Loja
  const { data: vendaReal, error: erroVenda } = await (supabaseAdmin
    .from('vendas') as any)
    .select('id, tenant_id, store_id, valor_final, valor_total')
    .eq('id', venda_id)
    .single();

  if (erroVenda || !vendaReal) return { success: false, message: 'Venda não encontrada.' };

  // --- TRAVA DE SEGURANÇA ---
  // Se não for Admin, só pode mexer se a loja do usuário for igual à da venda
  if (profile.role !== 'admin' && profile.store_id !== vendaReal.store_id) {
      return { success: false, message: 'Acesso Negado: Loja inválida.' };
  }

  // 6. Verificar duplicidade
  const { data: existente } = await (supabaseAdmin
    .from('financiamento_loja') as any)
    .select('id')
    .eq('venda_id', venda_id)
    .single();

  if (existente) return { success: false, message: 'Já existe um carnê ativo.' };

  // 7. Criar Capa
  const { data: capa, error: erroCapa } = await (supabaseAdmin
    .from('financiamento_loja') as any)
    .insert({
      tenant_id: vendaReal.tenant_id,
      store_id: vendaReal.store_id,
      venda_id: venda_id,
      customer_id: customer_id,
      employee_id: employee_id,
      valor_total_financiado: valor_total,
      quantidade_parcelas: Number(qtd_parcelas),
      data_inicio: data_primeiro_vencimento,
      obs: obs || '',
      created_by_user_id: user.id
    })
    .select()
    .single();

  if (erroCapa) return { success: false, message: `Erro ao criar contrato: ${erroCapa.message}` };
  
  const capaCriada: any = capa;

  // 8. Gerar Parcelas
  const valorParcela = Number((Number(valor_total) / Number(qtd_parcelas)).toFixed(2));
  const diferenca = Number((Number(valor_total) - (valorParcela * Number(qtd_parcelas))).toFixed(2));
  
  const parcelas = [];
  const dataBase = new Date(data_primeiro_vencimento);

  for (let i = 1; i <= Number(qtd_parcelas); i++) {
    const valorReal = i === 1 ? valorParcela + diferenca : valorParcela;
    const vencimento = new Date(dataBase);
    if (i > 1) vencimento.setMonth(vencimento.getMonth() + (i - 1));

    parcelas.push({
      tenant_id: vendaReal.tenant_id,
      store_id: vendaReal.store_id,
      financiamento_id: capaCriada.id,
      customer_id: customer_id,
      numero_parcela: i,
      data_vencimento: vencimento.toISOString().split('T')[0],
      valor_parcela: valorReal,
      valor_pago: 0,
      status: 'Pendente'
    });
  }

  const { error: erroParcelas } = await (supabaseAdmin.from('financiamento_parcelas') as any).insert(parcelas);

  if (erroParcelas) {
    await supabaseAdmin.from('financiamento_loja').delete().eq('id', capaCriada.id);
    return { success: false, message: `Erro ao gerar parcelas: ${erroParcelas.message}` };
  }

  // 9. Atualizar Venda
  const { data: pagamentosExistentes } = await (supabaseAdmin.from('pagamentos') as any)
    .select('valor_pago')
    .eq('venda_id', venda_id)
    .neq('forma_pagamento', 'Carnê');

  const totalJaPagoNoCaixa = pagamentosExistentes?.reduce((acc: number, p: any) => acc + Number(p.valor_pago), 0) || 0;
  const valorTotalVenda = Number(vendaReal.valor_final || vendaReal.valor_total);
  const totalCoberto = totalJaPagoNoCaixa + Number(valor_total);
  
  let novoValorRestante = valorTotalVenda - totalCoberto;
  if (novoValorRestante < 0.05 && novoValorRestante > -0.05) novoValorRestante = 0;
  const novoStatus = novoValorRestante <= 0 ? 'Fechada' : 'Em Aberto'; 

  const { error: erroUpdate } = await (supabaseAdmin.from('vendas') as any)
    .update({ 
      financiamento_id: capaCriada.id,
      valor_restante: novoValorRestante,
      status: novoStatus
    })
    .eq('id', venda_id);

  if (erroUpdate) return { success: false, message: `Erro ao atualizar venda: ${erroUpdate.message}` };

  revalidatePath(`/vendas/${venda_id}`);
  return { success: true, message: 'Carnê gerado com sucesso!' };
}

// ================================================================
// 14. ACTION: LISTAR VENDAS (COM FILTROS: PENDÊNCIAS OU PERÍODO)
// ================================================================
export type SalesFilterOptions = {
    mode?: 'pendencias' | 'historico'
    startDate?: string
    endDate?: string
}

export async function getSalesList(storeId: number, options?: SalesFilterOptions) {
  const supabaseAdmin = createAdminClient()
  
  const mode = options?.mode || 'pendencias'

  try {
    let query = supabaseAdmin
      .from('vendas')
      .select(`
        *,
        customers ( full_name )
      `)
      .eq('store_id', storeId)

    if (mode === 'pendencias') {
        // MODO PENDÊNCIAS: Traz tudo que está aberto, ignorando data (Prioridade Total)
        query = query.eq('status', 'Em Aberto')
                     .order('created_at', { ascending: true }) // Mais antigas primeiro (para resolver logo)
    } else {
        // MODO HISTÓRICO: Traz tudo (Aberto, Fechada, Cancelada) dentro do prazo
        if (options?.startDate) {
            const start = `${options.startDate}T00:00:00`
            query = query.gte('created_at', start)
        }
        if (options?.endDate) {
            const end = `${options.endDate}T23:59:59`
            query = query.lte('created_at', end)
        }
        // No histórico, queremos ver as mais recentes primeiro
        query = query.order('created_at', { ascending: false })
    }

    const { data, error } = await query

    if (error) throw error

    return { success: true, data }
  } catch (error: any) {
    return { success: false, message: error.message }
  }
}

// ================================================================
// 15. ACTION: BUSCA UNIFICADA DE PRODUTOS (ATUALIZADO)
// ================================================================
export type ProductSearchResult = {
  id: number
  tipo: 'Lente' | 'Armacao' | 'Tratamento' | 'Servico' | 'Outro'
  descricao: string
  detalhes: string
  preco_venda: number
  estoque?: number
}

export type SearchProductResult = {
  success: boolean
  message?: string
  data?: ProductSearchResult[]
}

// ATUALIZAÇÃO: Adicionado 'Todos' na assinatura para permitir busca global
export async function searchProductCatalog(
  query: string,
  storeId: number,
  type: 'Lente' | 'Armacao' | 'Tratamento' | 'Servico' | 'Outro' | 'Todos'
): Promise<SearchProductResult> {
  
  const supabaseAdmin = createAdminClient()
  let results: ProductSearchResult[] = []
  
  try {
      let q = supabaseAdmin
        .from('products')
        .select('*')
        .eq('store_id', storeId)

      // ATUALIZAÇÃO: Se for 'Todos', não filtra por tipo no banco
      if (type !== 'Todos') {
          let dbType = type
          if (type === 'Armacao') dbType = 'Armacao'
          if (type === 'Lente') dbType = 'Lente'
          if (type === 'Tratamento') dbType = 'Tratamento'
          if (type === 'Servico') dbType = 'Servico'
          if (type === 'Outro') dbType = 'Outro'
          
          q = q.eq('tipo_produto', dbType)
      }

      // Aplica a busca por texto
      q = q.or(`nome.ilike.%${query}%,codigo_barras.eq.${query},referencia.ilike.%${query}%`)
      q = q.limit(20)

      const { data } = await q

      if (data) {
          results = data.map((p: any) => {
              const d = p.detalhes || {}
              let detalhesStr = ''
              
              // ATUALIZAÇÃO: Mapeia o tipo do banco de volta para o tipo do Front
              let tipoFront: ProductSearchResult['tipo'] = 'Outro'
              if (p.tipo_produto === 'Lente') tipoFront = 'Lente'
              else if (p.tipo_produto === 'Armacao') tipoFront = 'Armacao'
              else if (p.tipo_produto === 'Tratamento') tipoFront = 'Tratamento'
              else if (p.tipo_produto === 'Servico') tipoFront = 'Servico'
              
              if (tipoFront === 'Lente') detalhesStr = `${p.marca || ''} ${d.material || ''}`
              if (tipoFront === 'Armacao') detalhesStr = `Ref: ${p.referencia || '-'} | Cor: ${d.cor || '-'}`
              if (tipoFront === 'Tratamento') detalhesStr = d.descricao || ''

              return {
                  id: p.id,
                  tipo: tipoFront, 
                  descricao: p.nome,
                  detalhes: detalhesStr,
                  preco_venda: p.preco_venda,
                  estoque: p.estoque_atual
              }
          })
      }

    return { success: true, data: results }

  } catch (error: any) {
    return { success: false, message: error.message }
  }
}

// ... (Mantenha o restante do arquivo inalterado)

// ================================================================
// 16. ACTION: BUSCA EXPRESS (CORRIGIDO COM 'ANY')
// ================================================================
export type ProdutoExpressResult = {
    id: number
    tipo_origem: 'produtos_gerais' | 'armacoes'
    descricao: string
    preco: number
    estoque: number
    codigo_barras: string | null
}

export async function buscarProdutoExpress(query: string, storeId: number) {
    const supabaseAdmin = createAdminClient()
    const termo = query.trim()
    const resultados: ProdutoExpressResult[] = []

    try {
        const { data } = await supabaseAdmin
            .from('products')
            .select('*')
            .eq('store_id', storeId)
            .in('tipo_produto', ['Armacao', 'Outro']) 
            .or(`codigo_barras.eq.${termo},nome.ilike.%${termo}%`)
            .limit(10)

        // CORREÇÃO: Adicionado (p: any) para o TypeScript aceitar as propriedades
        data?.forEach((p: any) => {
            resultados.push({
                id: p.id,
                // Mapeia para compatibilidade com o front antigo
                tipo_origem: p.tipo_produto === 'Armacao' ? 'armacoes' : 'produtos_gerais',
                descricao: p.nome,
                preco: p.preco_venda,
                estoque: p.estoque_atual,
                codigo_barras: p.codigo_barras
            })
        })

        return resultados

    } catch (e) {
        console.error("Erro busca express:", e)
        return []
    }
}

// ================================================================
// 17. ACTION: ATUALIZAR VENDEDOR DA VENDA
// ================================================================
export async function updateVendaEmployee(
  vendaId: number, 
  storeId: number, 
  employeeId: number | null
) {
  const supabaseAdmin = createAdminClient()
  try {
    // CORREÇÃO: Adicionado (as any) para destravar o update
    const { error } = await (supabaseAdmin.from('vendas') as any)
      .update({ employee_id: employeeId })
      .eq('id', vendaId)
      .eq('store_id', storeId)

    if (error) throw error
    
    revalidatePath(`/dashboard/loja/${storeId}/pdv-express`)
    return { success: true, message: 'Vendedor atualizado.' }
  } catch (e: any) {
    return { success: false, message: e.message }
  }
}
// ================================================================
// 18. ACTION: RECEBER PARCELA (COM LÓGICA DE JUROS HÍBRIDA)
// ================================================================
const ReceberParcelaSchema = z.object({
  parcela_id: z.coerce.number(),
  venda_id: z.coerce.number(),
  store_id: z.coerce.number(),
  employee_id: z.coerce.number(), 
  valor_original: z.coerce.number(),
  valor_pago_total: z.coerce.number().min(0.01), // Quanto dinheiro entrou
  valor_juros: z.coerce.number().default(0),     // Quanto disso é juros
  forma_pagamento: z.string().min(1),
  data_pagamento: z.string(),
  estrategia: z.enum(['quitacao_total', 'criar_pendencia', 'somar_proxima']).default('quitacao_total'),
})

export async function receberParcela(prevState: any, formData: FormData) {
  const supabaseAdmin = createAdminClient()
  const { data: { user } } = await createClient().auth.getUser()
  
  if (!user) return { success: false, message: 'Usuário não autenticado.' }
  
  const profile = await getProfileByAdmin(user.id)
  if (!profile) return { success: false, message: 'Perfil não encontrado.' }

  const valorRaw = formData.get('valor_pago_total') as string
  const valorPagoTotal = valorRaw ? parseFloat(valorRaw.replace(/\./g, '').replace(',', '.')) : 0

  const jurosRaw = formData.get('valor_juros') as string
  const valorJuros = jurosRaw ? parseFloat(jurosRaw.replace(/\./g, '').replace(',', '.')) : 0

  const inputData = {
      parcela_id: formData.get('parcela_id'),
      venda_id: formData.get('venda_id'),
      store_id: formData.get('store_id'),
      employee_id: formData.get('employee_id'),
      valor_original: formData.get('valor_original'),
      valor_pago_total: valorPagoTotal,
      valor_juros: valorJuros,
      forma_pagamento: formData.get('forma_pagamento'),
      data_pagamento: formData.get('data_pagamento'),
      estrategia: formData.get('estrategia')
  }

  const validated = ReceberParcelaSchema.safeParse(inputData)
  if (!validated.success) return { success: false, message: 'Dados inválidos.' }

  const { parcela_id, venda_id, store_id, valor_original, valor_pago_total, valor_juros, forma_pagamento, estrategia, data_pagamento } = validated.data
  
  // O PULO DO GATO MATEMÁTICO:
  // O quanto da dívida estamos matando? = (Dinheiro Total - Juros)
  const principalAbatido = valor_pago_total - valor_juros
  
  // A diferença real na dívida
  const diferencaDivida = valor_original - principalAbatido

  try {
      // 1. Busca dados da parcela atual
      const { data: parcelaRaw } = await supabaseAdmin
          .from('financiamento_parcelas')
          .select('*')
          .eq('id', parcela_id)
          .single()
      
      if (!parcelaRaw) throw new Error('Parcela não encontrada.')
      const parcelaAtual = parcelaRaw as any;

      // 2. Registra o Pagamento (Valor CHEIO que entrou no caixa)
      await (supabaseAdmin.from('pagamentos') as any).insert({
          tenant_id: (profile as any).tenant_id,
          store_id: store_id,
          venda_id: venda_id,
          created_by_user_id: user.id,
          valor_pago: valor_pago_total, // Entra R$ 60,00 no caixa
          forma_pagamento: forma_pagamento,
          data_pagamento: data_pagamento,
          parcelas: 1, 
          obs: `Ref. Parcela ${parcelaAtual.numero_parcela} (Principal: ${principalAbatido.toFixed(2)} + Juros: ${valor_juros.toFixed(2)})`
      })

      // 3. Baixa a parcela atual
      // IMPORTANTE: Atualizamos o valor_parcela para o que foi efetivamente abatido (R$ 50,00) para fins de histórico
      await (supabaseAdmin.from('financiamento_parcelas') as any).update({
          status: 'Pago',
          data_pagamento: new Date().toISOString(),
          valor_parcela: principalAbatido 
      }).eq('id', parcela_id)

      // 4. Lógica de Diferença da Dívida
      if (diferencaDivida > 0.01) {
          // --- FALTOU DINHEIRO (Cenário do Exemplo: Faltam R$ 50) ---
          
          if (estrategia === 'criar_pendencia') {
              await (supabaseAdmin.from('financiamento_parcelas') as any).insert({
                  tenant_id: (profile as any).tenant_id,
                  store_id: store_id,
                  financiamento_id: parcelaAtual.financiamento_id,
                  customer_id: parcelaAtual.customer_id,
                  numero_parcela: parcelaAtual.numero_parcela, // Mantém número para indicar que é 'filha'
                  data_vencimento: parcelaAtual.data_vencimento, // Vence hoje ou mantem original
                  valor_parcela: diferencaDivida,
                  status: 'Pendente'
              })
          } else if (estrategia === 'somar_proxima') {
              const { data: proxParcela } = await supabaseAdmin
                  .from('financiamento_parcelas')
                  .select('*')
                  .eq('financiamento_id', parcelaAtual.financiamento_id)
                  .gt('numero_parcela', parcelaAtual.numero_parcela)
                  .eq('status', 'Pendente')
                  .order('numero_parcela', { ascending: true })
                  .limit(1)
                  .maybeSingle()

              if (proxParcela) {
                  const prox = proxParcela as any;
                  await (supabaseAdmin.from('financiamento_parcelas') as any)
                      .update({ valor_parcela: prox.valor_parcela + diferencaDivida })
                      .eq('id', prox.id)
              } else {
                  // Se não tem próxima, cria nova para 30 dias
                  const novaData = new Date(parcelaAtual.data_vencimento)
                  novaData.setDate(novaData.getDate() + 30)
                  await (supabaseAdmin.from('financiamento_parcelas') as any).insert({
                      tenant_id: (profile as any).tenant_id,
                      store_id: store_id,
                      financiamento_id: parcelaAtual.financiamento_id,
                      customer_id: parcelaAtual.customer_id,
                      numero_parcela: parcelaAtual.numero_parcela + 1,
                      data_vencimento: novaData.toISOString(),
                      valor_parcela: diferencaDivida,
                      status: 'Pendente'
                  })
              }
          }
      } else if (diferencaDivida < -0.01) {
          // --- PAGOU A MAIS (AMORTIZAÇÃO) ---
          const excedente = Math.abs(diferencaDivida)

          const { data: proxParcela } = await supabaseAdmin
                  .from('financiamento_parcelas')
                  .select('*')
                  .eq('financiamento_id', parcelaAtual.financiamento_id)
                  .gt('numero_parcela', parcelaAtual.numero_parcela)
                  .eq('status', 'Pendente')
                  .order('numero_parcela', { ascending: true })
                  .limit(1)
                  .maybeSingle()
            
          if (proxParcela) {
              const prox = proxParcela as any;
              await (supabaseAdmin.from('financiamento_parcelas') as any)
                  .update({ valor_parcela: prox.valor_parcela - excedente })
                  .eq('id', prox.id)
          }
      }

      await (supabaseAdmin as any).rpc('update_venda_financeiro', { p_venda_id: venda_id })
      revalidatePath(`/dashboard/loja/${store_id}/vendas/${venda_id}`)

      return { success: true, message: 'Pagamento recebido com sucesso!' }

  } catch (e: any) {
      return { success: false, message: `Erro: ${e.message}` }
  }
}


// ==============================================================================
// 19. ACTION: EXCLUIR FINANCIAMENTO (FINAL: SEGURA + ADMIN MODE)
// ==============================================================================
export async function deleteFinanciamentoLoja(vendaId: number, storeId: number) {
  const supabaseAuth = createClient();
  const { data: { user } } = await supabaseAuth.auth.getUser();
  if (!user) return { success: false, message: 'Sessão inválida.' };

  const profile = await getProfileByAdmin(user.id) as any;
  if (!profile) return { success: false, message: 'Perfil não encontrado.' };

  // --- TRAVA DE SEGURANÇA ---
  if (profile.role !== 'admin' && profile.store_id !== storeId) {
       return { success: false, message: 'Acesso Negado: Loja inválida.' };
  }

  const supabaseAdmin = createAdminClient(); 

  try {
      const { data: financRaw, error: errFinanc } = await (supabaseAdmin
        .from('financiamento_loja') as any)
        .select('id')
        .eq('venda_id', vendaId)
        .maybeSingle();

      if (errFinanc) return { success: false, message: 'Erro técnico ao buscar carnê.' };
      const financ = financRaw as any;

      // Recalcular dívida
      const { data: vendaReal } = await (supabaseAdmin.from('vendas') as any)
          .select('valor_final, valor_total')
          .eq('id', vendaId).single();

      const { data: pagamentos } = await (supabaseAdmin.from('pagamentos') as any)
          .select('valor_pago')
          .eq('venda_id', vendaId).neq('forma_pagamento', 'Carnê');
      
      const totalPagoDinheiro = pagamentos?.reduce((acc: number, p: any) => acc + Number(p.valor_pago), 0) || 0;
      const valorVenda = Number(vendaReal?.valor_final || vendaReal?.valor_total || 0);
      const dividaRestaurada = valorVenda - totalPagoDinheiro;

      // Soltar Venda
      const { error: erroUpdate } = await (supabaseAdmin.from('vendas') as any)
        .update({ 
          financiamento_id: null,
          valor_restante: dividaRestaurada, 
          status: 'Em Aberto' 
        })
        .eq('id', vendaId);

      if (erroUpdate) return { success: false, message: `Erro ao atualizar venda: ${erroUpdate.message}` };

      // Limpar tabelas
      if (financ?.id) {
          await (supabaseAdmin.from('financiamento_parcelas') as any).delete().eq('financiamento_id', financ.id);
          await (supabaseAdmin.from('financiamento_loja') as any).delete().eq('id', financ.id);
      }

      revalidatePath(`/dashboard/loja/${storeId}/vendas/${vendaId}`);
      return { success: true, message: 'Carnê excluído. Saldo restaurado.' };

  } catch (e: any) {
      return { success: false, message: `Erro de sistema: ${e.message}` };
  }
}

// ================================================================
// 20. ACTION: SALVAR OBSERVAÇÃO (CPF NA NOTA)
// ================================================================
export async function updateVendaObs(
  vendaId: number, 
  storeId: number, 
  obs: string
) {
  // Placeholder por enquanto
  return { success: true, message: 'CPF registrado (Simulado).' }
}

// ================================================================
// 21. ACTION: FINALIZAR VENDA EXPRESS (ATÔMICA) - CORRIGIDO FINAL
// ================================================================
export async function finalizarVendaExpress(formData: FormData) {
    const supabaseAdmin = createAdminClient()
    
    const { data: { user } } = await createClient().auth.getUser()
    
    if (!user) return { success: false, message: 'Sem permissão.' }
    const profile = await getProfileByAdmin(user.id)
    
    const rawItens = JSON.parse(formData.get('itens') as string)
    const rawPagamento = JSON.parse(formData.get('pagamento') as string)
    
    // CORREÇÃO 1: Conversão explícita para Number
    const storeId = parseInt(formData.get('store_id') as string)
    const employeeId = parseInt(formData.get('employee_id') as string)

    const data = {
        store_id: storeId,
        employee_id: employeeId,
        itens: formData.get('itens'),
        pagamento: rawPagamento,
        cpf_nota: formData.get('cpf_nota')
    }

    // 1. Busca Consumidor Final (ou cria)
   let customerId: number
    
    // CORREÇÃO: Usamos .select().limit(1) em vez de .maybeSingle().
    // Isso garante que se houver 50 "Consumidor Final", ele pega o primeiro e não dá erro.
    const { data: clientesExistentes } = await (supabaseAdmin
  .from('customers') as any)
  .select('id')
  .eq('store_id', storeId)
  .ilike('full_name', 'Consumidor Final')
  .limit(1)

    
    if (clientesExistentes && clientesExistentes.length > 0) {
        // Pega o primeiro que encontrar (reutiliza)
        customerId = clientesExistentes[0].id
    } else {
        // Se não existir NENHUM, cria um novo
        const { data: novo } = await (supabaseAdmin.from('customers') as any).insert({
            store_id: storeId, 
            tenant_id: (profile as any).tenant_id, 
            full_name: 'Consumidor Final'
        }).select().single()
        
        customerId = (novo as any).id
    }
    
    // 2. Calcula Totais
    const totalVenda = rawItens.reduce((acc: number, item: any) => acc + (item.price * item.quantity), 0)

    // 3. INSERÇÃO (Venda)
    const { data: novaVenda, error: errVenda } = await (supabaseAdmin.from('vendas') as any).insert({
        store_id: storeId,
        tenant_id: (profile as any).tenant_id,
        customer_id: customerId,
        employee_id: employeeId,
        created_by_user_id: user.id,
        status: 'Fechada',
        valor_total: totalVenda,
        valor_final: totalVenda,
        valor_restante: 0
    }).select().single()

    if (errVenda) return { success: false, message: 'Erro ao criar venda.' }

    // 4. INSERÇÃO (Itens)
    const itensToInsert = rawItens.map((item: any) => ({
        tenant_id: (profile as any).tenant_id,
        store_id: storeId,
        venda_id: novaVenda.id,
        item_tipo: item.type === 'armacoes' ? 'Armacao' : 'Outro',
        descricao: item.description,
        quantidade: item.quantity,
        valor_unitario: item.price,
        valor_total_item: item.price * item.quantity,
        product_id: item.originalId,
        variant_id: null
    }))
    
    await (supabaseAdmin.from('venda_itens') as any).insert(itensToInsert)

    // 5. INSERÇÃO (Pagamento)
    await (supabaseAdmin.from('pagamentos') as any).insert({
        tenant_id: (profile as any).tenant_id,
        store_id: storeId,
        venda_id: novaVenda.id,
        created_by_user_id: user.id,
        valor_pago: data.pagamento.valor,
        forma_pagamento: data.pagamento.forma,
        parcelas: data.pagamento.parcelas,
        data_pagamento: data.pagamento.data,
        obs: data.cpf_nota ? `CPF Nota: ${data.cpf_nota}` : null
    })

await calcularERegistrarComissao(novaVenda.id)

    revalidatePath(`/dashboard/loja/${storeId}/vendas`)
    return { success: true, message: 'Venda finalizada!', vendaId: novaVenda.id }
}

// ================================================================
// 22. ACTION: CRIAR PARCIAL PARA CARNÊ (CORRIGIDO FINAL)
// ================================================================
export async function criarVendaParcialCarnê(formData: FormData) {
    const supabaseAdmin = createAdminClient()
    const { data: { user } } = await createClient().auth.getUser()
    const profile = await getProfileByAdmin(user!.id)

    // CORREÇÃO 1: Conversão explícita para Number
    const storeId = parseInt(formData.get('store_id') as string)
    const customerId = parseInt(formData.get('customer_id') as string)
    const employeeId = parseInt(formData.get('employee_id') as string)
    
    const rawItens = JSON.parse(formData.get('itens') as string)
    const totalVenda = rawItens.reduce((acc: number, item: any) => acc + (item.price * item.quantity), 0)

    // CORREÇÃO 2: Cast no insert da venda
    const { data: novaVenda, error } = await (supabaseAdmin.from('vendas') as any).insert({
        store_id: storeId,
        tenant_id: (profile as any).tenant_id,
        customer_id: customerId,
        employee_id: employeeId,
        created_by_user_id: user!.id,
        status: 'Em Aberto',
        valor_total: totalVenda,
        valor_final: totalVenda,
        valor_restante: totalVenda 
    }).select().single()

    if (error) return { success: false, message: error.message }

    const itensToInsert = rawItens.map((item: any) => ({
        tenant_id: (profile as any).tenant_id,
        store_id: storeId,
        venda_id: novaVenda.id,
        item_tipo: item.type === 'armacoes' ? 'Armacao' : 'Outro',
        descricao: item.description,
        quantidade: item.quantity,
        valor_unitario: item.price,
        valor_total_item: item.price * item.quantity,
        product_id: item.originalId,
        variant_id: null
    }))
    
    // CORREÇÃO 3: Cast no insert dos itens
    await (supabaseAdmin.from('venda_itens') as any).insert(itensToInsert)

    return { success: true, vendaId: novaVenda.id }
}

// ================================================================
// 23. ACTION: AUTENTICAR FUNCIONÁRIO POR PIN (FALTAVA ISSO)
// ================================================================
export type AuthEmployeeResult = {
  success: boolean
  message: string
  employee?: {
    id: number
    full_name: string
    role: 'vendedor' | 'gerente' | 'tecnico'
  }
}

export async function autenticarFuncionarioPorPin(
  prevState: AuthEmployeeResult,
  formData: FormData
): Promise<AuthEmployeeResult> {
  const storeId = parseInt(formData.get('store_id') as string)
  const pin = formData.get('pin') as string

  // Usamos AdminClient para ler o PIN (que é um dado sensível/interno)
  const supabaseAdmin = createAdminClient()

  try {
    const { data: employee } = await supabaseAdmin
      .from('employees')
      .select('id, full_name, role, is_active')
      .eq('store_id', storeId)
      .eq('pin', pin)
      .eq('is_active', true) // Só aceita ativos
      .maybeSingle()

 if (employee) {
  const emp: any = employee
  return {
    success: true,
    message: 'Autenticado com sucesso.',
    employee: {
      id: emp.id,
      full_name: emp.full_name,
      role: emp.role as 'vendedor' | 'gerente' | 'tecnico' || 'vendedor'
    }
  }
}


    return { success: false, message: 'PIN incorreto ou funcionário inativo.' }

  } catch (error) {
    console.error("Erro auth pin:", error)
    return { success: false, message: 'Erro ao validar PIN.' }
  }
}
// ================================================================
// 24. ACTION: BUSCAR HISTÓRICO DE VENDAS (DOSSIÊ DO CLIENTE) - V3 (FINAL)
// ================================================================
export type CustomerSaleHistory = {
  venda_id: number
  data: string
  valor_total: number
  status_venda: string
  paciente_nome: string
  itens: {
      descricao: string
      quantidade: number
      valor_unitario: number
      valor_total: number
  }[]
  financeiro: {
    tem_carne: boolean
    status_geral: 'Quitado' | 'Em dia' | 'Atrasado'
    resumo_parcelas: string
    parcelas_detalhes: {
        numero: number
        valor: number
        vencimento: string
        status: string
    }[]
    forma_pagamento_resumo: string // NOVO CAMPO
  }
  tecnico: {
    tem_os: boolean
    os_id?: number
    longe_od: string
    longe_oe: string
    adicao: string
    medico: string
  } | null
}

export async function getLastSalesForCustomer(storeId: number, customerId: number): Promise<{ success: boolean, data?: CustomerSaleHistory[] }> {
  const supabaseAdmin = createAdminClient()

  try {
    // 1. Busca as vendas
    const { data: vendas, error: errVendas } = await supabaseAdmin
        .from('vendas')
        .select('id, created_at, valor_final, status, customer_id')
        .eq('store_id', storeId)
        .eq('customer_id', customerId)
        .order('created_at', { ascending: false })
        .limit(2)

    if (errVendas || !vendas || vendas.length === 0) return { success: true, data: [] }

    const vendasIds = (vendas as any[]).map(v => v.id)


    // 2. Busca dados relacionados
    const [itensRes, osRes, financRes, clienteRes, pagtosRes] = await Promise.all([
        supabaseAdmin.from('venda_itens').select('venda_id, descricao, quantity:quantidade, unit_price:valor_unitario, total:valor_total_item').in('venda_id', vendasIds),
        supabaseAdmin.from('service_orders').select('*, dependentes(full_name), oftalmologistas(nome_completo)').in('venda_id', vendasIds),
        supabaseAdmin.from('financiamento_loja').select('*, financiamento_parcelas(numero_parcela, valor_parcela, data_vencimento, status)').in('venda_id', vendasIds),
        supabaseAdmin.from('customers').select('full_name').eq('id', customerId).single(),
        supabaseAdmin.from('pagamentos').select('venda_id, forma_pagamento, parcelas').in('venda_id', vendasIds)
    ])

   
    const clienteNome = (clienteRes.data as any)?.full_name || 'Cliente'


    // 3. Monta o Dossiê
    const history: CustomerSaleHistory[] = vendas.map((v: any) => {
        
        // A. Itens
        
        const rawItens = (itensRes.data as any[])?.filter(i => i.venda_id === v.id) || []

        const itensFormatados = rawItens.map((i: any) => ({
            descricao: i.descricao,
            quantidade: i.quantity,
            valor_unitario: i.unit_price,
            valor_total: i.total
        }))

        // B. OS / Paciente
        const os = (osRes.data as any[])?.find(o => o.venda_id === v.id)

        let paciente = clienteNome
if (os?.dependentes?.full_name) paciente = os.dependentes.full_name
        else if (os && !os.dependente_id) paciente = clienteNome 

        // C. Financeiro & Forma de Pagamento
        
        const financ = (financRes.data as any[])?.find(f => f.venda_id === v.id)
        const pagamentosDaVenda = (pagtosRes.data as any[])?.filter(p => p.venda_id === v.id) || []

        
        let finStatus: 'Quitado' | 'Em dia' | 'Atrasado' = 'Quitado'
        let finResumo = '' // Ex: "3/5 Parc."
        let formaResumo = '' // Ex: "Pix", "Cartão 3x"
        let parcelasDetalhadas: any[] = []

        if (financ) {
            // Lógica Carnê
            const parcelas = financ.financiamento_parcelas || []
            parcelas.sort((a: any, b: any) => a.numero_parcela - b.numero_parcela)
            
            parcelasDetalhadas = parcelas.map((p: any) => ({
                numero: p.numero_parcela,
                valor: p.valor_parcela,
                vencimento: p.data_vencimento,
                status: p.status
            }))

            const totalP = parcelas.length
            const pagas = parcelas.filter((p: any) => p.status === 'Pago').length
            const atrasadas = parcelas.filter((p: any) => p.status === 'Pendente' && new Date(p.data_vencimento) < new Date(new Date().setHours(0,0,0,0))).length
            
            finResumo = `${pagas}/${totalP} Parc.`
            
            if (atrasadas > 0) finStatus = 'Atrasado'
            else if (pagas < totalP) finStatus = 'Em dia'
            else finStatus = 'Quitado'
            
            formaResumo = `Carnê (${totalP}x)`
        } else {
            // Lógica Pagamento Comum
            if (pagamentosDaVenda.length > 0) {
                // Pega a forma principal (ou concatena se tiver várias)
                const formasUnicas = Array.from(new Set(pagamentosDaVenda.map((p: any) => {
                    const parc = p.parcelas > 1 ? ` ${p.parcelas}x` : ''
                    return `${p.forma_pagamento}${parc}`
                })))
                formaResumo = formasUnicas.join(' + ')
            } else {
                formaResumo = 'Pendente'
            }
        }

        // D. Dados Técnicos (Mantido igual)
        let tecnicoData = null
        if (os) {
            tecnicoData = {
                tem_os: true,
                os_id: os.id,
                longe_od: `${os.receita_longe_od_esferico || ''} ${os.receita_longe_od_cilindrico || ''}`.trim() || '-',
                longe_oe: `${os.receita_longe_oe_esferico || ''} ${os.receita_longe_oe_cilindrico || ''}`.trim() || '-',
                adicao: os.receita_adicao || '-',
                medico: os.oftalmologistas?.nome_completo || 'Não informado'
            }
        }

        return {
            venda_id: v.id,
            data: v.created_at,
            valor_total: v.valor_final,
            status_venda: v.status,
            paciente_nome: paciente,
            itens: itensFormatados,
            financeiro: {
                tem_carne: !!financ,
                status_geral: finStatus,
                resumo_parcelas: finResumo,
                parcelas_detalhes: parcelasDetalhadas,
                forma_pagamento_resumo: formaResumo // Enviando pro front
            },
            tecnico: tecnicoData
        }
    })

    return { success: true, data: history }

  } catch (e: any) {
      console.error("Erro ao buscar histórico:", e)
      return { success: false, data: [] }
  }
}

// ================================================================
// 25. ACTION: BUSCAR HISTÓRICO DE RECEITAS (MODAL DE IMPORTAÇÃO)
// ================================================================
export type PrescriptionHistoryItem = {
  id: number
  created_at: string
  receita_longe_od_esferico: string | null
  receita_longe_od_cilindrico: string | null
  receita_longe_od_eixo: string | null
  receita_longe_oe_esferico: string | null
  receita_longe_oe_cilindrico: string | null
  receita_longe_oe_eixo: string | null
  receita_perto_od_esferico: string | null
  receita_perto_od_cilindrico: string | null
  receita_perto_od_eixo: string | null
  receita_perto_oe_esferico: string | null
  receita_perto_oe_cilindrico: string | null
  receita_perto_oe_eixo: string | null
  receita_adicao: string | null
  medida_dnp_od: string | null
  medida_dnp_oe: string | null
  oftalmologistas: {
      nome_completo: string
  } | null
}

export async function getCustomerPrescriptionHistory(
  customerId: number, 
  storeId: number, 
  dependenteId: number | null
): Promise<PrescriptionHistoryItem[]> {
  const supabaseAdmin = createAdminClient()

  try {
    let query = supabaseAdmin
        .from('service_orders')
        .select(`
            id, created_at,
            receita_longe_od_esferico, receita_longe_od_cilindrico, receita_longe_od_eixo,
            receita_longe_oe_esferico, receita_longe_oe_cilindrico, receita_longe_oe_eixo,
            receita_perto_od_esferico, receita_perto_od_cilindrico, receita_perto_od_eixo,
            receita_perto_oe_esferico, receita_perto_oe_cilindrico, receita_perto_oe_eixo,
            receita_adicao, medida_dnp_od, medida_dnp_oe,
            oftalmologistas ( nome_completo )
        `)
        .eq('store_id', storeId)
        .eq('customer_id', customerId)
        // Filtra para pegar apenas receitas que tenham algum dado preenchido
        .not('receita_longe_od_esferico', 'is', null)
        .order('created_at', { ascending: false })

    // Se um dependente específico estiver selecionado, filtra por ele.
    // Se não (dependenteId é null), busca as receitas do Titular (onde dependente_id é null)
    if (dependenteId) {
        query = query.eq('dependente_id', dependenteId)
    } else {
        query = query.is('dependente_id', null)
    }

    const { data, error } = await query

    if (error) {
        console.error('Erro ao buscar histórico de receitas:', error)
        return []
    }

    return data as any
  } catch (e) {
    return []
  }
}

// ... (imports)

// ================================================================
// 26. ACTION: BUSCAR PENDÊNCIAS (VERSÃO CORRIGIDA E LIMPA)
// ================================================================
export async function searchPendenciasCliente(storeId: number, termo: string) {
    const supabaseAdmin = createAdminClient()
    const cleanTerm = termo.trim()

    console.log(`🔍 [DEBUG] Iniciando busca para: "${cleanTerm}" na Loja: ${storeId}`)

    try {
        // PASSO 1: Busca Clientes
        const { data: clientes, error: errCli } = await supabaseAdmin
            .from('customers')
            .select('id, full_name, cpf')
            .eq('store_id', storeId)
            .or(`full_name.ilike.%${cleanTerm}%,cpf.ilike.%${cleanTerm}%`)
            .limit(50)
        
        if (errCli) {
            console.error("❌ [DEBUG] Erro ao buscar clientes:", errCli.message)
            return []
        }

        console.log(`👤 [DEBUG] Clientes encontrados:`, clientes?.length || 0)
        
        if (!clientes || clientes.length === 0) return []

        const idsClientes = clientes.map((c: any) => c.id)

        // PASSO 2: Busca Parcelas
        const { data: parcelas, error: errParc } = await (supabaseAdmin
            .from('financiamento_parcelas') as any)
            .select(`
                id, 
                numero_parcela, 
                valor_parcela, 
                data_vencimento,
                financiamento_id,
                customer_id,
                status,
                financiamento_loja ( 
                    venda_id,
                    vendas!financiamento_loja_venda_id_fkey (
                        created_at,
                        service_orders (
                            dependente_id,
                            dependentes ( full_name )
                        )
                    )
                )
            `)
            .in('customer_id', idsClientes)
            .eq('store_id', storeId)
            .order('data_vencimento', { ascending: true })

        if (errParc) {
            console.error("❌ [DEBUG] Erro ao buscar parcelas:", errParc.message)
            return []
        }

        const parcelasPendentes = parcelas?.filter((p: any) => p.status === 'Pendente') || []
        console.log(`📦 [DEBUG] Parcelas pendentes encontradas:`, parcelasPendentes.length)

        // PASSO 3: Agrupamento
        const resultado = clientes.map((cli: any) => {
            const parcs = parcelasPendentes.filter((p: any) => p.customer_id === cli.id)

            if (parcs.length === 0) return null

            const parcsFormatadas = parcs.map((p: any) => {
                const venda = p.financiamento_loja?.vendas
                const os = venda?.service_orders?.[0]
                
                const nomeDependente = os?.dependentes?.full_name
                const nomeTitular = cli.full_name
                
                const beneficiario = (nomeDependente && nomeDependente !== nomeTitular) 
                    ? nomeDependente 
                    : null

                return {
                    id: p.id,
                    numero_parcela: p.numero_parcela,
                    valor_parcela: p.valor_parcela,
                    data_vencimento: p.data_vencimento,
                    venda_id: p.financiamento_loja?.venda_id,
                    data_venda: venda?.created_at,
                    beneficiario: beneficiario
                }
            })

            return {
                cliente: cli,
                parcelas: parcsFormatadas
            }
        }).filter(Boolean)

        console.log(`🚀 [DEBUG] Sucesso! Retornando ${resultado.length} grupos.`)
        return resultado

    } catch (e) {
        console.error("🔥 [DEBUG] Exceção crítica:", e)
        return []
    }
}

// ================================================================
// 27. ACTION: MARCAR PAGAMENTOS COMO IMPRESSOS
// ================================================================
export async function markPaymentsAsPrinted(
  paymentIds: number[]
): Promise<{ success: boolean }> {
  const supabaseAdmin = createAdminClient()
  try {
    await (supabaseAdmin.from('pagamentos') as any)
      .update({ receipt_printed_at: new Date().toISOString() })
      .in('id', paymentIds)

    return { success: true }
  } catch (e) {
    console.error("Erro ao marcar impressão:", e)
    return { success: false }
  }
}

// ... (mantenha o restante do arquivo como está)

// ================================================================
// 28. ACTION: BUSCAR ITENS COMPRADOS (PARA ASSISTÊNCIA)
// ================================================================
export type ItemComprado = {
    venda_item_id: number
    venda_id: number
    data_venda: string
    descricao: string
    product_id: number | null
    valor: number
}

export async function getItensCompradosPorCliente(storeId: number, customerId: number): Promise<ItemComprado[]> {
    const supabaseAdmin = createAdminClient()
    
    try {
        // Busca itens das últimas 20 vendas do cliente
        // Cast 'as any' para garantir os joins
        const { data, error } = await (supabaseAdmin.from('venda_itens') as any)
            .select(`
                id, 
                descricao, 
                product_id, 
                valor_total_item,
                vendas!inner ( id, created_at, status )
            `)
            .eq('store_id', storeId)
            .eq('vendas.customer_id', customerId)
            .neq('vendas.status', 'Cancelada') // Ignora canceladas
            .order('id', { ascending: false })
            .limit(50)

        if (error) throw error
        
        return (data || []).map((i: any) => ({
            venda_item_id: i.id,
            venda_id: i.vendas.id,
            data_venda: i.vendas.created_at,
            descricao: i.descricao,
            product_id: i.product_id,
            valor: i.valor_total_item
        }))

    } catch (e) {
        console.error("Erro ao buscar compras:", e)
        return []
    }
}



==================================================
ARQUIVO: .\src\lib\actions\wallet.actions.ts
==================================================
// ARQUIVO: src/lib/actions/wallet.actions.ts
'use server'

import { createAdminClient, getProfileByAdmin } from '@/lib/supabase/admin'
import { createClient } from '@/lib/supabase/server'
import { Database } from '@/lib/database.types'
import { revalidatePath } from 'next/cache'
import { z } from 'zod'

type Wallet = Database['public']['Tables']['customer_wallets']['Row']
type WalletTransaction = Database['public']['Tables']['wallet_transactions']['Row']

// --- TIPOS DE RETORNO ---
export type GetWalletResult = {
    success: boolean
    data?: {
        balance: number
        transactions: WalletTransaction[]
    }
    message?: string
}

export type WalletActionResult = {
    success: boolean
    message: string
}

// ==============================================================================
// 1. BUSCAR CARTEIRA (SALDO + EXTRATO)
// ==============================================================================
export async function getWallet(storeId: number, customerId: number): Promise<GetWalletResult> {
    const supabaseAdmin = createAdminClient()

    try {
        // 1. Busca Saldo Atual
        // CORREÇÃO: Cast 'as any' para select em customer_wallets
        const { data: wallet } = await (supabaseAdmin
            .from('customer_wallets') as any)
            .select('id, balance')
            .eq('store_id', storeId)
            .eq('customer_id', customerId)
            .maybeSingle()

        // Se não tem carteira, saldo é 0
        const currentBalance = wallet?.balance || 0
        const walletId = wallet?.id

        let transactions: WalletTransaction[] = []

        // 2. Busca Extrato (apenas se existir carteira)
        if (walletId) {
            // CORREÇÃO: Cast 'as any' para select em wallet_transactions
            const { data: trans } = await (supabaseAdmin
                .from('wallet_transactions') as any)
                .select('*')
                .eq('wallet_id', walletId)
                .order('created_at', { ascending: false }) // Mais recente primeiro
            
            if (trans) transactions = trans
        }

        return {
            success: true,
            data: {
                balance: currentBalance,
                transactions
            }
        }

    } catch (error: any) {
        console.error("Erro ao buscar carteira:", error)
        return { success: false, message: "Erro interno ao carregar carteira." }
    }
}

// ==============================================================================
// 2. ADICIONAR CRÉDITO (DEVOLUÇÃO)
// ==============================================================================
const AddCreditSchema = z.object({
    store_id: z.coerce.number(),
    customer_id: z.coerce.number(),
    amount: z.coerce.number().positive("O valor do crédito deve ser positivo."),
    description: z.string().min(3),
    employee_id: z.coerce.number(), // Quem autorizou (PIN)
    related_venda_id: z.coerce.number().optional().nullable()
})

export async function addCredit(formData: FormData): Promise<WalletActionResult> {
    const supabaseAdmin = createAdminClient()
    const { data: { user } } = await createClient().auth.getUser()
    
    if (!user) return { success: false, message: 'Usuário não autenticado.' }
    
    // CORREÇÃO: Cast 'as any' para garantir acesso ao tenant_id e store_id
    const profile = await getProfileByAdmin(user.id) as any
    if (!profile) return { success: false, message: 'Perfil inválido.' }

    const inputData = {
        store_id: formData.get('store_id'),
        customer_id: formData.get('customer_id'),
        amount: formData.get('amount'),
        description: formData.get('description'),
        employee_id: formData.get('employee_id'),
        related_venda_id: formData.get('related_venda_id')
    }

    const validated = AddCreditSchema.safeParse(inputData)
    if (!validated.success) return { success: false, message: 'Dados inválidos.' }

    const { store_id, customer_id, amount, description, employee_id, related_venda_id } = validated.data

    try {
        // 1. Busca ou Cria a Carteira (Upsert)
        // Primeiro tentamos buscar para pegar o ID
        // CORREÇÃO: Cast 'as any'
        let { data: wallet } = await (supabaseAdmin
            .from('customer_wallets') as any)
            .select('id, balance')
            .eq('store_id', store_id)
            .eq('customer_id', customer_id)
            .maybeSingle()

        if (!wallet) {
            // Cria nova carteira zerada
            // CORREÇÃO: Cast 'as any'
            const { data: newWallet, error: createError } = await (supabaseAdmin
                .from('customer_wallets') as any)
                .insert({
                    tenant_id: profile.tenant_id,
                    store_id,
                    customer_id,
                    balance: 0
                })
                .select()
                .single()
            
            if (createError) throw new Error("Erro ao criar carteira: " + createError.message)
            wallet = newWallet
        }

        // 2. Atualiza o Saldo (Adiciona o valor)
        const novoSaldo = Number(wallet.balance) + amount
        
        // CORREÇÃO: Cast 'as any'
        await (supabaseAdmin
            .from('customer_wallets') as any)
            .update({ balance: novoSaldo, updated_at: new Date().toISOString() })
            .eq('id', wallet.id)

        // 3. Registra o Extrato (Transaction)
        // CORREÇÃO: Cast 'as any'
        await (supabaseAdmin.from('wallet_transactions') as any).insert({
            tenant_id: profile.tenant_id,
            store_id,
            wallet_id: wallet.id,
            amount: amount, // Positivo
            operation_type: 'Credito_Devolucao',
            description,
            related_venda_id: related_venda_id || null,
            employee_id, // Quem autorizou
            created_by_user_id: user.id // Quem estava logado
        })

        revalidatePath(`/dashboard/loja/${store_id}/clientes`)
        return { success: true, message: `Crédito de R$ ${amount.toFixed(2)} adicionado!` }

    } catch (e: any) {
        return { success: false, message: e.message }
    }
}

// ==============================================================================
// 3. USAR CRÉDITO (PAGAMENTO)
// ==============================================================================
const UseCreditSchema = z.object({
    store_id: z.coerce.number(),
    customer_id: z.coerce.number(),
    amount: z.coerce.number().positive("O valor deve ser positivo."),
    description: z.string().min(3),
    employee_id: z.coerce.number(), // Vendedor que está usando
    related_venda_id: z.coerce.number() // Obrigatório vincular a uma venda nova
})

export async function useCredit(formData: FormData): Promise<WalletActionResult> {
    const supabaseAdmin = createAdminClient()
    const { data: { user } } = await createClient().auth.getUser()
    
    if (!user) return { success: false, message: 'Usuário não autenticado.' }
    
    // CORREÇÃO: Cast 'as any'
    const profile = await getProfileByAdmin(user.id) as any

    const inputData = {
        store_id: formData.get('store_id'),
        customer_id: formData.get('customer_id'),
        amount: formData.get('amount'),
        description: formData.get('description'),
        employee_id: formData.get('employee_id'),
        related_venda_id: formData.get('related_venda_id')
    }

    const validated = UseCreditSchema.safeParse(inputData)
    if (!validated.success) return { success: false, message: 'Dados inválidos.' }

    const { store_id, customer_id, amount, description, employee_id, related_venda_id } = validated.data

    try {
        // 1. Busca Carteira e Verifica Saldo
        // CORREÇÃO: Cast 'as any'
        const { data: wallet } = await (supabaseAdmin
            .from('customer_wallets') as any)
            .select('id, balance')
            .eq('store_id', store_id)
            .eq('customer_id', customer_id)
            .single()

        if (!wallet) return { success: false, message: "Cliente não possui carteira digital." }
        
        if (wallet.balance < amount) {
            return { success: false, message: `Saldo insuficiente. Disponível: R$ ${wallet.balance}` }
        }

        // 2. Debita o Saldo
        const novoSaldo = Number(wallet.balance) - amount

        // CORREÇÃO: Cast 'as any'
        await (supabaseAdmin
            .from('customer_wallets') as any)
            .update({ balance: novoSaldo, updated_at: new Date().toISOString() })
            .eq('id', wallet.id)

        // 3. Registra Extrato (Negativo)
        // CORREÇÃO: Cast 'as any'
        await (supabaseAdmin.from('wallet_transactions') as any).insert({
            tenant_id: profile?.tenant_id,
            store_id,
            wallet_id: wallet.id,
            amount: -amount, // Negativo para indicar saída
            operation_type: 'Uso_Venda',
            description,
            related_venda_id: related_venda_id,
            employee_id,
            created_by_user_id: user.id
        })

        revalidatePath(`/dashboard/loja/${store_id}/clientes`)
        return { success: true, message: `Crédito utilizado com sucesso!` }

    } catch (e: any) {
        return { success: false, message: e.message }
    }
}

==================================================
ARQUIVO: .\src\lib\actions\xml.actions.ts
==================================================
'use server'

import { createClient } from '@/lib/supabase/server'
import { createAdminClient, getProfileByAdmin } from '@/lib/supabase/admin'
import { XMLParser } from 'fast-xml-parser'
import { revalidatePath } from 'next/cache'

// Tipos para o Preview
export type XmlPreviewItem = {
    codigo_fornecedor: string
    codigo_barras: string // cEAN
    descricao: string
    ncm: string
    cest: string
    cfop: string
    unidade: string
    quantidade: number
    valor_unitario: number // Custo Calculado (Com impostos)
    valor_total: number
    // Status para a UI
    status_sistema: 'Novo' | 'Encontrado' | 'Vinculado'
    id_sistema?: number // Se já existir
    estoque_atual?: number
}

export type XmlPreviewData = {
    access_key: string // Chave de Acesso (44 dígitos)
    nfe_numero: string
    nfe_serie: string
    data_emissao: string
    fornecedor: {
        cnpj: string
        nome: string // xNome
        fantasia: string // xFant
        ie: string // IE
        cidade: string
        uf: string
        status_sistema: 'Novo' | 'Cadastrado'
        id_sistema?: number
    }
    itens: XmlPreviewItem[]
}

// Helper para limpar string de chave (remove 'NFe' se tiver)
const cleanKey = (key: string) => key?.replace('NFe', '') || ''

// Helper seguro para float
const parseFloatSafe = (val: any) => {
    if (!val) return 0
    return parseFloat(val)
}

// ============================================================================
// 1. LER XML E GERAR PREVIEW (COM TRAVA E CUSTO EFETIVO)
// ============================================================================
export async function parseNfeAndPreview(formData: FormData): Promise<{ success: boolean, data?: XmlPreviewData, message?: string }> {
    const supabaseAdmin = createAdminClient()
    const { data: { user } } = await createClient().auth.getUser()
    if (!user) return { success: false, message: 'Login necessário.' }
    
    const profile = await getProfileByAdmin(user.id)
    if (!profile) return { success: false, message: 'Perfil não encontrado.' }

    const file = formData.get('xml_file') as File
    if (!file) return { success: false, message: 'Arquivo não enviado.' }

    try {
        const text = await file.text()
        const parser = new XMLParser({ ignoreAttributes: false, attributeNamePrefix: "@_" })
        const xmlObj = parser.parse(text)

        // Navegar na estrutura NFe
        const nfeProc = xmlObj.nfeProc || xmlObj.NFe
        if (!nfeProc || !nfeProc.NFe) throw new Error("XML inválido ou não é uma NFe.")
        
        const infNFe = nfeProc.NFe.infNFe
        
        // 1. TRAVA DE SEGURANÇA: Verificar Chave de Acesso
        const rawKey = infNFe["@_Id"] 
        if (!rawKey) throw new Error("Chave de acesso não encontrada no XML.")
        
        const accessKey = cleanKey(rawKey)
        
        const { data: invoiceExists } = await (supabaseAdmin.from('imported_invoices') as any)
            .select('id, imported_at')
            .eq('store_id', (profile as any).store_id)
            .eq('access_key', accessKey)
            .maybeSingle()

        if (invoiceExists) {
            const dataImp = new Date(invoiceExists.imported_at).toLocaleDateString('pt-BR')
            return { success: false, message: `ATENÇÃO: Esta nota fiscal já foi importada no dia ${dataImp}.` }
        }

        // 2. Dados Gerais
        const emit = infNFe.emit
        const detList = Array.isArray(infNFe.det) ? infNFe.det : [infNFe.det] 

        // 3. Processar Fornecedor
        const cnpjFornecedor = emit.CNPJ
        const fornecedorPreview = {
            cnpj: cnpjFornecedor,
            nome: emit.xNome,
            fantasia: emit.xFant || emit.xNome,
            ie: emit.IE,
            cidade: emit.enderEmit?.xMun || '',
            uf: emit.enderEmit?.UF || '',
            status_sistema: 'Novo' as 'Novo' | 'Cadastrado',
            id_sistema: undefined as number | undefined
        }

        // Verifica se fornecedor existe no banco
        const { data: existingSupplier } = await (supabaseAdmin.from('suppliers') as any)
            .select('id')
            .eq('store_id', (profile as any).store_id)
            .eq('cnpj', cnpjFornecedor)
            .maybeSingle()

        if (existingSupplier) {
            fornecedorPreview.status_sistema = 'Cadastrado'
            fornecedorPreview.id_sistema = existingSupplier.id
        }

        // 4. Processar Produtos
        const itensPreview: XmlPreviewItem[] = []
        const eansDoXml = detList.map((d: any) => d.prod.cEAN).filter((c: string) => c && c !== 'SEM GTIN')
        
        const { data: produtosExistentes } = await (supabaseAdmin.from('products') as any)
            .select('id, codigo_barras, estoque_atual, nome')
            .eq('store_id', (profile as any).store_id)
            .in('codigo_barras', eansDoXml)

        for (const det of detList) {
            const prod = det.prod
            const impostos = det.imposto || {}
            
            // CÁLCULO DO CUSTO EFETIVO (LANDED COST)
            const vProd = parseFloatSafe(prod.vProd)
            const qCom = parseFloatSafe(prod.qCom)
            const vDesc = parseFloatSafe(prod.vDesc)
            const vFrete = parseFloatSafe(prod.vFrete)
            const vSeg = parseFloatSafe(prod.vSeg)
            const vOutro = parseFloatSafe(prod.vOutro)
            
            const vIPI = parseFloatSafe(impostos.IPI?.IPITrib?.vIPI)
            const vST = parseFloatSafe(impostos.ICMS?.ICMS10?.vICMSST) || parseFloatSafe(impostos.ICMS?.ICMS30?.vICMSST) || parseFloatSafe(impostos.ICMS?.ICMS70?.vICMSST) || parseFloatSafe(impostos.ICMS?.ICMS90?.vICMSST) || 0
            
            const custoTotalItem = vProd + vIPI + vST + vFrete + vSeg + vOutro - vDesc
            const custoUnitarioReal = custoTotalItem / qCom

            const match = produtosExistentes?.find((p: any) => p.codigo_barras === prod.cEAN)

            itensPreview.push({
                codigo_fornecedor: prod.cProd,
                codigo_barras: prod.cEAN !== 'SEM GTIN' ? prod.cEAN : '',
                descricao: prod.xProd,
                ncm: String(prod.NCM || ''),
                cest: String(prod.CEST || ''),
                cfop: prod.CFOP,
                unidade: prod.uCom,
                quantidade: qCom,
                valor_unitario: parseFloat(custoUnitarioReal.toFixed(2)),
                valor_total: vProd,
                status_sistema: match ? 'Encontrado' : 'Novo',
                id_sistema: match?.id,
                estoque_atual: match?.estoque_atual
            })
        }

        return {
            success: true,
            data: {
                access_key: accessKey,
                nfe_numero: infNFe.ide.nNF,
                nfe_serie: infNFe.ide.serie,
                data_emissao: infNFe.ide.dhEmi,
                fornecedor: fornecedorPreview,
                itens: itensPreview
            }
        }

    } catch (e: any) {
        console.error("Erro ao ler XML:", e)
        return { success: false, message: "Erro ao processar XML: " + e.message }
    }
}

// ============================================================================
// 2. GRAVAR DADOS (COMMIT)
// ============================================================================
export async function saveImportedData(data: XmlPreviewData, storeId: number) {
    const supabaseAdmin = createAdminClient()
    const { data: { user } } = await createClient().auth.getUser()
    if (!user) return { success: false, message: 'Login necessário.' }
    const profile = await getProfileByAdmin(user.id)
    if (!profile) return { success: false, message: 'Perfil inválido.' }

    try {
        // 1. Salvar/Atualizar Fornecedor
        let supplierId = data.fornecedor.id_sistema

        if (!supplierId) {
            // Se não existe, cria na tabela 'suppliers'
            const { data: newSup, error } = await (supabaseAdmin.from('suppliers') as any).insert({
                tenant_id: (profile as any).tenant_id,
                store_id: storeId,
                nome_fantasia: data.fornecedor.fantasia,
                razao_social: data.fornecedor.nome,
                cnpj: data.fornecedor.cnpj,
                inscricao_estadual: data.fornecedor.ie,
                cidade: data.fornecedor.cidade,
                uf: data.fornecedor.uf
            }).select().single()
            
            if (error) throw new Error("Erro ao criar fornecedor: " + error.message)
            supplierId = newSup.id
        }

        // 2. Processar Produtos
        for (const item of data.itens) {
            
            const nome = item.descricao.toUpperCase()
            const ncmString = String(item.ncm || '') 
            const ncm = ncmString.replace(/\./g, '')
            
            let tipoDetectado = 'Outro'
            let categoriaDetectada = 'Importado XML'

            // Lógica de Detecção de Tipo (Priorizando NCM)
            // NCMs de Ótica: 9003 (Armações), 9004 (Óculos), 9001 (Lentes)
            if (ncm.startsWith('9003') || ncm.startsWith('9004')) {
                tipoDetectado = 'Armacao'
                categoriaDetectada = 'Armação'
            } else if (ncm.startsWith('9001')) {
                tipoDetectado = 'Lente'
                categoriaDetectada = 'Lente Oftálmica'
            } else {
                // Fallback por Nome se NCM não for conclusivo
                if (nome.includes('ARMA') || nome.includes('OCULOS') || nome.includes('SOLAR')) {
                    tipoDetectado = 'Armacao'
                    categoriaDetectada = 'Armação'
                } else if (nome.includes('LENTE')) {
                    tipoDetectado = 'Lente'
                    categoriaDetectada = 'Lente Oftálmica'
                }
            }

            const precoVendaSugerido = item.valor_unitario * 2 

            let productId = item.id_sistema

            if (productId) {
                // PRODUTO JÁ EXISTE: Atualiza estoque e custo (mas não mexe na marca/nome)
                const { error: updateError } = await (supabaseAdmin as any).rpc('increment_stock', { 
                    p_product_id: productId, 
                    p_quantity: item.quantidade,
                    p_new_cost: item.valor_unitario
                })
                
                if (updateError) { 
                    const { data: prodAtual } = await (supabaseAdmin.from('products') as any)
                        .select('estoque_atual')
                        .eq('id', productId)
                        .single()
                        
                    await (supabaseAdmin.from('products') as any).update({
                        estoque_atual: (prodAtual?.estoque_atual || 0) + item.quantidade,
                        preco_custo: item.valor_unitario,
                    }).eq('id', productId)
                }
            } else {
                // PRODUTO NOVO: Cria o registro
                const { data: newProd, error: insertError } = await (supabaseAdmin.from('products') as any).insert({
                    tenant_id: (profile as any).tenant_id,
                    store_id: storeId,
                    nome: item.descricao,
                    codigo_barras: item.codigo_barras || null,
                    referencia: item.codigo_fornecedor,
                    tipo_produto: tipoDetectado, 
                    categoria: categoriaDetectada,
                    
                    // Marca: Deixamos NULL para preenchimento manual correto depois
                    marca: null, 
                    
                    preco_custo: item.valor_unitario,
                    preco_venda: precoVendaSugerido,
                    estoque_atual: item.quantidade,
                    estoque_minimo: 1,
                    gerencia_estoque: true,
                    ncm: ncm,
                    cest: item.cest,
                    cfop: item.cfop,
                    unidade_medida: item.unidade,
                    origem_mercadoria: 0,
                    supplier_id: supplierId, // Vínculo com a tabela Suppliers
                    detalhes: {} 
                }).select().single()

                if (insertError) throw new Error(`Erro ao criar produto ${item.descricao}: ${insertError.message}`)
                productId = newProd.id
            }

            // 3. Registrar Movimentação (Log)
            await (supabaseAdmin.from('stock_movements') as any).insert({
                tenant_id: (profile as any).tenant_id,
                store_id: storeId,
                product_id: productId,
                tipo: 'Entrada',
                quantidade: item.quantidade,
                motivo: `Importação NFe ${data.nfe_numero}`,
                custo_unitario_momento: item.valor_unitario,
                registrado_por_id: user.id
            })
        }

        // 4. Registrar a Nota na Tabela de Controle (Trava de Duplicidade)
        await (supabaseAdmin.from('imported_invoices') as any).insert({
            tenant_id: (profile as any).tenant_id,
            store_id: storeId,
            access_key: data.access_key,
            nfe_number: data.nfe_numero,
            series: data.nfe_serie,
            supplier_id: supplierId,
            imported_at: new Date().toISOString()
        })

        revalidatePath(`/dashboard/loja/${storeId}/cadastros`)
        return { success: true, message: "Importação concluída com sucesso!" }

    } catch (e: any) {
        if (e.message?.includes('unique_invoice_key_per_store')) {
            return { success: false, message: "Erro: Esta nota fiscal já foi registrada no sistema." }
        }
        console.error("Erro ao salvar importação:", e)
        return { success: false, message: e.message }
    }
}

==================================================
ARQUIVO: .\src\lib\supabase\admin.ts
==================================================
// Caminho: src/lib/supabase/admin.ts

import { createClient } from '@supabase/supabase-js'
import { Database } from '@/lib/database.types'

// Cliente Admin (Service Role)
export function createAdminClient() {
    const url = process.env.NEXT_PUBLIC_SUPABASE_URL
    const serviceRole = process.env.SUPABASE_SERVICE_ROLE_KEY

    if (!url || !serviceRole) {
        throw new Error('Chaves de Service Role não configuradas.')
    }

    return createClient<Database>(url, serviceRole, {
        auth: {
            autoRefreshToken: false,
            persistSession: false
        }
    })
}

export async function getProfileByAdmin(userId: string) {
    try {
        const supabaseAdmin = createAdminClient()

        const { data: profile } = await supabaseAdmin
            .from('profiles')
            .select('role, store_id, tenant_id')
            .eq('id', userId)
            .single()

        return profile
    } catch (e) {
        console.error("ERRO ao buscar perfil com Service Role:", e)
        return null
    }
}


==================================================
ARQUIVO: .\src\lib\supabase\client.ts
==================================================
// Caminho: src/lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}

==================================================
ARQUIVO: .\src\lib\supabase\server.ts
==================================================
// Caminho: src/lib/supabase/server.ts (CORRIGIDO PARA CONSISTÊNCIA)

import { createServerClient, type CookieOptions } from '@supabase/ssr'
import { cookies } from 'next/headers'

export function createClient() {
  const cookieStore = cookies()

  return createServerClient(
    // USAR CHAVES PÚBLICAS PARA CONSISTÊNCIA E ACESSO NO SSR
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value
        },
        set(name: string, value: string, options: CookieOptions) {
          try {
            cookieStore.set({ name, value, ...options })
          } catch (error) {
            // Ocorre em Server Actions, o que é esperado
          }
        },
        remove(name: string, options: CookieOptions) {
          try {
            cookieStore.set({ name, value: '', ...options })
          } catch (error) {
            // Ocorre em Server Actions, o que é esperado
          }
        },
      },
    }
  )
}
